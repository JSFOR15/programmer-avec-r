%%% Copyright (C) 2017 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet «Programmer avec R»
%%% http://github.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition selon le contrat
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% http://creativecommons.org/licenses/by-sa/4.0/

\chapter{Structures de données de R}
\label{chap:donnees}

<<echo=FALSE>>=
options(width=52)
@

\begin{objectifs}
\item Distinguer les caractéristiques des structures de données
  suivantes de R: le vecteur simple, la matrice, le tableau, la liste,
  le \emph{data frame} et le facteur.
\item Créer et manipuler chacune des structures de données ci-dessus.
\item Extraire des données des divers types d'objet ou y affecter de
  nouvelles valeurs à l'aide des méthodes d'indiçage.
\item Importer dans R des données provenant de sources externes.
\item Exporter des données de R vers un format exploitable par
  d'autres outils.
\end{objectifs}

Une structure de données est une manière d'organiser les données dans
un ordinateur afin de pouvoir les traiter efficacement. L'étude des
structures de données va généralement de pair avec celle des
algorithmes puisqu'elles en influencent directement la performance. Le
bon choix de structure de données peut faire la différence entre un
programme performant et un autre trop lent ou inapte à traiter des
grandes quantités de données.

Le modèle de données de R repose sur des structures abstraites et
spécialisées que nous avons appelé des \emph{objets}. Jusqu'à
maintenant, nous n'avons étudié que le vecteur simple (\emph{atomic}).
Il existe d'autres structures de données en R --- c'est l'objet de ce
chapitre! ---, mais leur mise en œuvre demeure tout à fait
transparente pour les programmeuses et les programmeurs. Cet ouvrage
fera donc l'impasse sur les notions de tableau (\emph{array}), de
liste chainée (\emph{linked list}), d'arbre (\emph{tree}) ou de table
de hachage (\emph{hashtable}) dont traitent habituellement les
ouvrages d'algorithmique et de programmation.


\section{Matrices et tableaux}
\label{sec:donnees:matrices}

R étant un langage spécialisé pour les calculs mathématiques, il
supporte tout naturellement et de manière intuitive --- à une
exception près, comme nous le verrons --- les matrices et, plus
généralement, les tableaux à plusieurs dimensions.

Les \capsule{https://youtu.be/indicage}{matrices et tableaux} ne sont
rien d'autre que des vecteurs dotés d'un attribut \attribut{dim}. Ces
objets sont donc stockés, et peuvent être manipulés, exactement comme
des vecteurs simples.

\begin{itemize}
\item Une matrice est un vecteur avec un attribut \attribut{dim} de
  longueur $2$. Cela change implicitement la classe de l'objet pour
  \indexclasse{matrix}\code{"matrix"} et, de ce fait, le mode
  d'affichage de l'objet ainsi que son interaction avec plusieurs
  opérateurs et fonctions.
\item La fonction de base pour créer des matrices est
  \Fonction{matrix}:
<<echo=TRUE>>=
matrix(1:6, nrow = 2, ncol = 3)
matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE)
@
\item La généralisation d'une matrice à plus de deux dimensions est un
  tableau (\emph{array}). Le nombre de dimensions du tableau est
  toujours égal à la longueur de l'attribut \attribut{dim}. La classe
  implicite d'un tableau est \indexclasse{array}\code{"array"}.
\item La fonction de base pour créer des tableaux est
  \Fonction{array}:
<<echo=TRUE>>=
array(1:24, dim = c(3, 4, 2))
@
\end{itemize}

\begin{important}
  On remarquera ci-dessus que les matrices et tableaux sont remplis en
  faisant d'abord varier la première dimension, puis la seconde, etc.
  Pour les matrices, cela revient à remplir par colonne. On conviendra
  que cette convention, héritée du Fortran, n'est pas des plus
  intuitives.

  La fonction \code{matrix} a un argument \argument{byrow} qui permet
  d'inverser l'ordre de remplissage. Cependant, il vaut mieux
  s'habituer à la convention de R que d'essayer constamment de la
  contourner.
\end{important}

L'ordre de remplissage inhabituel des tableaux rend leur manipulation
difficile si on ne les visualise pas correctement. Imaginons un
tableau de dimensions $3 \times 4 \times 5$.
\begin{itemize}
\item Il faut voir le tableau comme cinq matrices $3 \times 4$
  (remplies par colonne!) les unes \emph{derrière} les autres.
\item Autrement dit, le tableau est un prisme rectangulaire haut de $3$
  unités, large de $4$ et profond de $5$.
\item Si l'on ajoute une quatrième dimension, cela revient à aligner
  des prismes les uns derrière les autres, et ainsi de suite.
\end{itemize}
La \autoref{fig:donnees:tableaux} fournit une représentation schématique
des tableaux à trois et quatre dimensions.

\begin{figure}[t]
  \centering
  \hspace*{\fill}
  \begin{minipage}[b]{0.4\linewidth}
    \setlength{\unitlength}{5mm}
    \begin{picture}(9,7)
      \ttfamily
      \put(0,0){\framebox(5,4)[tl]{}}
      \multiput(1,4)(1,1){3}{\line(0,1){1}}
      \multiput(1,5)(1,1){3}{\line(1,0){5}}
      \multiput(6,5)(1,1){3}{\line(0,-1){4}}
      \multiput(6,1)(1,1){3}{\line(-1,0){1}}
      \put(0.5,3.5){\circle{0.6}}\put(0.51,3.51){\makebox(0,0){\footnotesize 1}}
      \put(0.5,3){\vector(0,-1){2.5}}
      \put(1.5,3.5){\circle{0.6}}\put(1.51,3.51){\makebox(0,0){\footnotesize 2}}
      \put(2,3.5){\vector(1,0){2.5}}
      \put(6.3,0.3){\circle{0.6}}\put(6.31,0.31){\makebox(0,0){\footnotesize 3}}
      \put(6.7,0.7){\vector(1,1){1.3}}
    \end{picture}
    \subcaption{trois dimensions}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\linewidth}
    \setlength{\unitlength}{5mm}
    \setlength{\unitlength}{3.5mm}
    \begin{picture}(14,12)
      \ttfamily
      \put(0,0){\framebox(5,4)[tl]{}}
      \multiput(1,4)(1,1){3}{\line(0,1){1}}
      \multiput(1,5)(1,1){3}{\line(1,0){5}}
      \multiput(6,5)(1,1){3}{\line(0,-1){4}}
      \multiput(6,1)(1,1){3}{\line(-1,0){1}}
      \put(6,7){\line(0,1){2}}
      \put(6,9){\line(1,0){5}}
      \put(11,9){\line(0,-1){4}}
      \put(11,5){\line(-1,0){3}}
      \multiput(7,9)(1,1){3}{\line(0,1){1}}
      \multiput(7,10)(1,1){3}{\line(1,0){5}}
      \multiput(12,10)(1,1){3}{\line(0,-1){4}}
      \multiput(12,6)(1,1){3}{\line(-1,0){1}}
      \put(0.5,3.5){\circle{0.8}}\put(0.51,3.51){\makebox(0,0){\scriptsize 1}}
      \put(0.5,2.9){\vector(0,-1){2.4}}
      \put(1.5,3.5){\circle{0.8}}\put(1.51,3.51){\makebox(0,0){\scriptsize 2}}
      \put(2.1,3.5){\vector(1,0){2.4}}
      \put(6.3,0.3){\circle{0.8}}\put(6.31,0.31){\makebox(0,0){\scriptsize 3}}
      \put(6.7,0.7){\vector(1,1){1.3}}
      \put(7.3,0.3){\circle{0.8}}\put(7.31,0.31){\makebox(0,0){\scriptsize 4}}
      \put(7.7,0.7){\vector(1,1){6.3}}
    \end{picture}
    \subcaption{quatre dimensions}
  \end{minipage}
  \caption{Représentation schématique de tableaux. Les chiffres encerclés
    identifient l'ordre de remplissage.}
  \label{fig:donnees:tableaux}
\end{figure}

Comme pour les vecteurs, l'indiçage\index{indiçage!matrice} des
matrices et tableaux se fait avec les crochets \fonction{[~]}.
\begin{itemize}
\item On extrait un élément d'une matrice en précisant sa position
  dans chaque dimension de celle-ci, séparées par des virgules:
<<echo=TRUE>>=
(m <- matrix(c(40, 80, 45, 21, 55, 32),
             nrow = 2, ncol = 3))
m[1, 2]
@
\item On peut aussi ne donner que la position de l'élément dans le
  vecteur sous-jacent:
<<echo=TRUE>>=
m[3]
@
\item \label{pg:donnees:indicage_matrice} Lorsqu'une dimension est omise
  dans les crochets, tous les éléments de cette dimension sont
  extraits:
<<echo=TRUE>>=
m[2, ]
@
\item Les idées sont les mêmes pour les tableaux.
\item Pour le reste, les règles d'indiçage de vecteurs exposées à la
  \autoref{sec:bases:indicage} s'appliquent à chaque position de
  l'indice d'une matrice ou d'un tableau.
\end{itemize}

Des fonctions permettent de fusionner des matrices et des tableaux
ayant au moins une dimension identique.
\begin{itemize}
\item La fonction \Fonction{rbind} permet de fusionner verticalement
  deux matrices (ou plus) ayant le même nombre de colonnes.
<<echo=TRUE>>=
n <- matrix(1:9, nrow = 3)
rbind(m, n)
@
\item La fonction \Fonction{cbind} permet de fusionner horizontalement
  deux matrices (ou plus) ayant le même nombre de lignes.
<<echo=TRUE>>=
n <- matrix(1:4, nrow = 2)
cbind(m, n)
@
\end{itemize}


\section{Listes}
\label{sec:donnees:listes}

La liste\index{liste} est le mode de stockage le plus général et
polyvalent du langage R. Il s'agit d'un type de vecteur spécial dont
les éléments peuvent être de n'importe quel mode, y compris le mode
\mode{list}. Cela permet donc d'emboîter des listes, d'où le
qualificatif de \emph{récursif} pour ce type d'objet.

\begin{itemize}
\item La fonction de base pour créer des listes est \Fonction{list}:
<<echo=TRUE>>=
(x <- list(size = c(1, 5, 2), user = "Joe", new = TRUE))
@ %
  Ci-dessus, le premier élément de la liste est de mode
  \code{"numeric"}, le second de mode \code{"character"} et le troisième
  de mode \code{"logical"}.
\item Nous recommandons de nommer les éléments d'une liste. En effet,
  les listes contiennent souvent des données de types différents et il
  peut s'avérer difficile d'identifier les éléments s'ils ne sont pas
  nommés. De plus, comme nous le verrons ci-dessous, il est très
  simple d'extraire les éléments d'une liste par leur étiquette.
\item La liste demeure un vecteur. On peut donc
  l'indicer\Index{indiçage!liste} avec l'opérateur \fonction{[~]}.
  Cependant, cela retourne une liste contenant le ou les éléments
  indicés. C'est rarement ce que l'on souhaite.
\item Pour indicer un élément d'une liste et n'obtenir que cet
  élément, et non une liste contenant l'élément, il faut utiliser
  l'opérateur d'indiçage \Fonction{[[~]]}. Comparer
<<echo=TRUE>>=
x[1]
@ %
  et
<<echo=TRUE>>=
x[[1]]
@
  Évidemment, on ne peut extraire qu'un seul élément à la fois
  avec les crochets doubles \code{[[~]]}.
\item Petite subtilité peu employée, mais élégante. Si l'indice
  utilisé dans \fonction{[[~]]} est un vecteur, il est utilisé
  récursivement pour indicer la liste: cela sélectionnera la
  composante de la liste correspondant au premier élément du vecteur,
  puis l'élément de la composante correspondant au second élément du
  vecteur, et ainsi de suite.
\item Une autre --- la meilleure, en fait --- façon d'indicer un seul
  élément d'une liste est par son étiquette avec l'opérateur \Fonction{\$}:
<<echo=TRUE>>=
x$size
@
\item La fonction \Fonction{unlist} convertit une liste en un vecteur
  simple. Elle est surtout utile pour concaténer les éléments d'une
  liste lorsque ceux-ci sont des scalaires. Attention, cette fonction
  peut être destructrice si la structure interne de la liste est
  importante.
\end{itemize}


\section{\emph{Data frames}}
\label{sec:donnees:dataframes}

Les vecteurs, les matrices, les tableaux et les listes sont les types
d'objets les plus fréquemment utilisés en programmation en R.
Toutefois, un grand nombre de procédures statistiques --- pensons à la
régression linéaire, par exemple --- repose davantage sur les
\emph{data frames} pour le stockage des données.

\begin{itemize}
\item Un \emph{data frame} est une liste de classe
  \indexclasse{data.frame}\code{"data.frame"} dont tous les éléments
  sont de la même longueur (ou comptent le même nombre de lignes si
  les éléments sont des matrices).
\item Il est généralement représenté sous la forme d'un tableau à deux
  dimensions. Chaque élément de la liste sous-jacente correspond à une
  colonne.
\item Bien que visuellement similaire à une matrice un \emph{data
    frame} est plus général puisque les colonnes peuvent être de modes
  différents; pensons à un tableau avec des noms (mode
  \code{character}) dans une colonne et des notes (mode
  \code{numeric}) dans une autre.
\item On crée un \emph{data frame} avec la fonction
  \Fonction{data.frame} ou, pour convertir un autre type d'objet en
  \emph{data frame}, avec \Fonction{as.data.frame}.
\item Le \emph{data frame} peut être indicé à la fois comme une liste
  et comme une matrice.
\item Les fonctions \fonction{rbind} et \fonction{cbind} peuvent être
  utilisées pour ajouter des lignes ou des colonnes à un \emph{data
    frame}.
\item On peut rendre les colonnes d'un \emph{data frame} (ou d'une
  liste) visibles dans l'espace de travail avec la fonction
  \Fonction{attach}, puis les masquer avec \Fonction{detach}.
\end{itemize}


%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
