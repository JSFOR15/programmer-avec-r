%%% Copyright (C) 2017 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet «Programmer avec R»
%%% http://github.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition selon le contrat
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% http://creativecommons.org/licenses/by-sa/4.0/

\chapter{Structures de données de R}
\label{chap:donnees}

<<echo=FALSE>>=
options(width=52)
@

\begin{objectifs}
\item Distinguer les caractéristiques des structures de données
  suivantes de R: le vecteur simple, la matrice, le tableau, la liste,
  le \emph{data frame} et le facteur.
\item Créer et manipuler chacune des structures de données ci-dessus.
\item Extraire des données des divers types d'objet ou y affecter de
  nouvelles valeurs à l'aide des méthodes d'indiçage.
\item Importer dans R des données provenant de sources externes.
\item Exporter des données de R vers un format exploitable par
  d'autres outils.
\end{objectifs}

Une structure de données est une manière d'organiser les données dans
un ordinateur afin de pouvoir les traiter efficacement. L'étude des
structures de données va généralement de pair avec celle des
algorithmes puisqu'elles en influencent directement la performance. Le
bon choix de structure de données peut faire la différence entre un
programme performant et un autre trop lent ou inapte à traiter des
grandes quantités de données.

Le modèle de données de R repose sur des structures abstraites et
spécialisées que nous avons appelé des \emph{objets}. Jusqu'à
maintenant, nous n'avons étudié que le vecteur simple (\emph{atomic}).
Il existe d'autres structures de données en R --- c'est l'objet de ce
chapitre! ---, mais leur mise en œuvre demeure tout à fait
transparente pour les programmeuses et les programmeurs. Cet ouvrage
fera donc l'impasse sur les notions de tableau (\emph{array}), de
liste chainée (\emph{linked list}), d'arbre (\emph{tree}) ou de table
de hachage (\emph{hashtable}) dont traitent habituellement les
ouvrages d'algorithmique et de programmation.


\section{Matrice et tableau}
\label{sec:donnees:matrice}

R étant un langage spécialisé dans les calculs mathématiques, il
supporte tout naturellement et de manière intuitive --- à une
exception près, comme nous le verrons --- les
\capsule{https://youtu.be/indicage}{matrices et tableaux}. Dans la
terminologie de R, une matrice est un tableau rectangulaire de nombres
à deux dimensions, alors qu'un tableau (\emph{array}) est la
généralisation à plus de deux dimensions\footnote{%
  Il est donc correct de dire qu'une matrice est un tableau à deux
  dimensions.}. %

Nous avons établi d'entrée de jeu à la \autoref{sec:bases:vecteurs}
qu'en R, tout est un vecteur. C'est aussi vrai pour les matrices et
tableaux, qui ne sont rien d'autre que des vecteurs dotés d'un
attribut \icode{dim} (\autoref{sec:bases:objets:attributs}). Ces
objets sont donc stockés, et peuvent être manipulés, exactement comme
des vecteurs simples.

Une \Index{matrice}matrice est un vecteur avec un attribut \icode{dim}
de longueur $2$. La présence de cet attribut change implicitement la
classe de l'objet et, de ce fait, son mode d'affichage (sous forme de
tableau rectangulaire) et son interaction avec plusieurs opérateurs et
fonctions, notamment les opérateurs d'indiçage. La fonction de base
pour créer une matrice est \Icode{matrix}:
<<echo=TRUE>>=
matrix(1:6, nrow = 2, ncol = 3)
matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE)
@

Tel que mentionné précédemment, la généralisation d'une matrice à plus
de deux dimensions est un \Index{tableau}tableau. Le nombre de
dimensions du tableau est toujours égal à la longueur de l'attribut
\icode{dim}. La fonction de base pour créer des tableaux est
\Icode{array}:
<<echo=TRUE>>=
array(1:24, dim = c(3, 4, 2))
@

Formellement, un tableau peut aussi compter une seule dimension. Un
tel tableau comporte un attribut \code{dim} de longueur $1$, alors
qu'un vecteur simple n'a pas d'attribut \code{dim}.

\importantbox{%
  Vous aurez remarqué que les matrices et tableaux sont remplis en
  faisant d'abord varier la première dimension, puis la seconde, etc.
  Pour les matrices, cela revient à les remplir par colonne. Cette
  convention, héritée du Fortran, n'est pas des plus intuitives, mais
  elle a ses avantages dans plusieurs applications.

  La fonction \icode{matrix} possède un argument \code{byrow} qui
  permet d'inverser l'ordre de remplissage, mais il vaut mieux
  vous habituer à la convention de R qu'essayer constamment de la
  contourner.}

L'ordre de remplissage inhabituel des tableaux rend leur manipulation
difficile si on ne les visualise pas correctement. Imaginons un
tableau de dimensions $3 \times 4 \times 5$: il faut voir le tableau
comme cinq matrices $3 \times 4$ (remplies par colonne!) les unes
\emph{derrière} les autres. Autrement dit, le tableau est un prisme
rectangulaire haut de $3$ unités, large de $4$ et profond de $5$. Si
l'on ajoute une quatrième dimension, cela revient à aligner des
prismes les uns derrière les autres, et ainsi de suite. La
\autoref{fig:donnees:tableaux} fournit une représentation schématique
des tableaux à trois et quatre dimensions.

\begin{figure}[t]
  \centering
  \hspace*{\fill}
  \begin{minipage}[b]{0.4\linewidth}
    \setlength{\unitlength}{5mm}
    \begin{picture}(9,7)
      \fullcaps
      \put(0,0){\framebox(5,4)[tl]{}}
      \multiput(1,4)(1,1){3}{\line(0,1){1}}
      \multiput(1,5)(1,1){3}{\line(1,0){5}}
      \multiput(6,5)(1,1){3}{\line(0,-1){4}}
      \multiput(6,1)(1,1){3}{\line(-1,0){1}}
      \put(0.5,3.5){\circle{0.7}}\put(0.51,3.51){\makebox(0,0){\footnotesize 1}}
      \put(0.5,3){\vector(0,-1){2.5}}
      \put(1.5,3.5){\circle{0.7}}\put(1.51,3.51){\makebox(0,0){\footnotesize 2}}
      \put(2,3.5){\vector(1,0){2.5}}
      \put(6.3,0.3){\circle{0.7}}\put(6.31,0.31){\makebox(0,0){\footnotesize 3}}
      \put(6.7,0.7){\vector(1,1){1.3}}
    \end{picture}
    \subcaption{trois dimensions}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\linewidth}
    \setlength{\unitlength}{5mm}
    \setlength{\unitlength}{3.5mm}
    \begin{picture}(14,12)
      \fullcaps
      \put(0,0){\framebox(5,4)[tl]{}}
      \multiput(1,4)(1,1){3}{\line(0,1){1}}
      \multiput(1,5)(1,1){3}{\line(1,0){5}}
      \multiput(6,5)(1,1){3}{\line(0,-1){4}}
      \multiput(6,1)(1,1){3}{\line(-1,0){1}}
      \put(6,7){\line(0,1){2}}
      \put(6,9){\line(1,0){5}}
      \put(11,9){\line(0,-1){4}}
      \put(11,5){\line(-1,0){3}}
      \multiput(7,9)(1,1){3}{\line(0,1){1}}
      \multiput(7,10)(1,1){3}{\line(1,0){5}}
      \multiput(12,10)(1,1){3}{\line(0,-1){4}}
      \multiput(12,6)(1,1){3}{\line(-1,0){1}}
      \put(0.5,3.5){\circle{0.8}}\put(0.51,3.51){\makebox(0,0){\scriptsize 1}}
      \put(0.5,2.9){\vector(0,-1){2.4}}
      \put(1.5,3.5){\circle{0.8}}\put(1.51,3.51){\makebox(0,0){\scriptsize 2}}
      \put(2.1,3.5){\vector(1,0){2.4}}
      \put(6.3,0.3){\circle{0.8}}\put(6.31,0.31){\makebox(0,0){\scriptsize 3}}
      \put(6.7,0.7){\vector(1,1){1.3}}
      \put(7.3,0.3){\circle{0.8}}\put(7.31,0.31){\makebox(0,0){\scriptsize 4}}
      \put(7.7,0.7){\vector(1,1){6.3}}
    \end{picture}
    \subcaption{quatre dimensions}
  \end{minipage}
  \caption{Représentation schématique de tableaux. Les chiffres encerclés
    identifient l'ordre de remplissage.}
  \label{fig:donnees:tableaux}
\end{figure}

L'indiçage\Index{indiçage!matrice} des matrices et tableaux se fait
avec les crochets \code{[~]}\indexcode{[}, comme pour les vecteurs
simples. D'ailleurs, l'ensemble des règles d'indiçage de la
\autoref{sec:bases:vecteurs:indicage} s'appliquent à l'identique aux
matrices tableaux, sinon qu'il faut maintenant préciser des
indices pour chaque dimension, séparés par des virgules.

Par exemple, on extrait un élément d'une matrice en précisant sa
position dans chaque dimension de celle-ci.
<<echo=TRUE>>=
(m <- matrix(c(40, 80, 45, 21, 55, 32), nrow = 2))
m[1, 2]
@

Il est équivalent --- quoique moins usité --- d'utiliser la position
de l'élément dans le vecteur sous-jacent à la matrice.
<<echo=TRUE>>=
m[3]
@

Les indices négatifs suppriment des dimensions et les vecteurs
booléens sélectionnent des dimensions, comme d'habitude.
<<echo=TRUE>>=
m[-1, -2]
m[c(FALSE, TRUE), c(FALSE, TRUE, TRUE)]
@

En vertu de la cinquième règle d'indiçage de la
\autoref{sec:bases:vecteurs:indicage}, lorsqu'une dimension est
laissée vide dans les crochets, tous les éléments de cette dimension
sont extraits.
<<echo=TRUE>>=
m[2, ]
m[, 1]
m[-1, ]
m[, -2]
@

Les fonctions \Icode{rbind} et \Icode{cbind} permettent de fusionner
des matrices et des tableaux ayant au moins une dimension en commun.
La fonction \Icode{rbind} (\emph{row bind}) fusionne verticalement
(empile) deux matrices (ou plus) ayant le même nombre de colonnes.
<<echo=TRUE>>=
n <- matrix(1:9, nrow = 3)
rbind(m, n)
@

La fonction \Icode{cbind} (\emph{column bind}), quant à elle, fusionne
horizontalement (place côte à côte) deux matrices (ou plus) ayant le
même nombre de lignes.
<<echo=TRUE>>=
n <- matrix(1:4, nrow = 2)
cbind(m, n)
@


\section{Liste}
\label{sec:donnees:liste}

La liste\index{liste} est la structure de données la plus générale et
polyvalente du langage R. Si les éléments d'un vecteur simple doivent
tous être du même mode, ceux de la liste peuvent être de n'importe
quel mode, y compris le mode \icode{list}. Par conséquent, il est
possible d'emboîter des listes, d'où le qualificatif de
\emph{récursif} pour ce type d'objet.

La fonction de base pour créer des listes est \Icode{list}:
<<echo=TRUE>>=
(x <- list(size = c(1, 5, 2), user = "Joe", new = TRUE))
@ %

(Dans l'exemple ci-dessus, le premier élément de la liste est de mode
\code{numeric}, le second de mode \code{character} et le troisième
de mode \code{logical}.)

\tipbox{%
  Nommez les éléments des listes. En effet, les listes contiennent
  souvent des données de types différents et il peut s'avérer
  difficile d'identifier les éléments s'ils ne sont pas nommés. De
  plus, comme nous le verrons ci-dessous, il est très simple
  d'extraire les éléments d'une liste par leur étiquette.}

L'indiçage\Index{indiçage!liste} des listes recèle quelques subtilités
auxquelles il faut porter une attention particulière. Tout d'abord, il
existe trois opérateurs d'indiçage: les crochets simples usuels
\code{[~]}, les crochets doubles \code{[[~]]} et le signe de dollar
\code{\$}.

Les crochets simples\icode{[} fonctionnent avec la liste
comme avec tout vecteur. Le résultat de l'indiçage avec \code{[~]} est
une liste. Quand on y pense, c'est le seul résultat logique lorsque
l'on indice une liste avec un vecteur. Par conséquent, le résultat de
l'extraction d'un seul élément d'une liste avec les crochets simples
est non pas l'objet en question, mais bien une liste d'un élément
contenant l'objet. C'est rarement ce que l'on souhaite obtenir.
<<echo=TRUE>>=
x[1]
x[-2]
x[c(1, 3)]
@

Les crochets doubles\Icode{[[} permettent d'extraire un, et
un seul, élément d'une liste à l'aide d'un entier positif ou d'une
chaine de caractères. Le résultat est l'objet «sorti» de la liste.
<<echo=TRUE>>=
x[[1]]
x[["size"]]
@

Petite fonctionnalité peu employée, mais élégante des crochets
doubles: si l'indice est un vecteur d'entiers positifs, R utilisera
les valeurs de celui-ci pour indicer récursivement la liste. Autrement
dit, R sélectionnera la composante de la liste correspondant au
premier élément du vecteur, puis l'élément de la composante
correspondant au second élément du vecteur, et ainsi de suite.
<<echo=TRUE>>=
x[[c(1, 2)]]
@

Finalement, l'autre façon --- la meilleure, en fait --- de
sélectionner un seul élément d'une liste est par son étiquette avec
l'opérateur \Icode{\$}.
<<echo=TRUE>>=
x$size
@

Mentionnons en terminant la fonction \Icode{unlist} qui convertit une
liste en un vecteur simple. Elle est surtout utile pour concaténer les
éléments d'une liste lorsque ceux-ci sont des vecteurs simples.
Attention, toutefois: cette fonction est destructrice si la structure
interne de la liste est importante.


\section{\emph{Data frames}}
\label{sec:donnees:dataframes}

Les vecteurs, les matrices, les tableaux et les listes sont les types
d'objets les plus fréquemment utilisés en programmation en R.
Toutefois, un grand nombre de procédures statistiques --- pensons à la
régression linéaire, par exemple --- repose davantage sur les
\emph{data frames} pour le stockage des données.

\begin{itemize}
\item Un \emph{data frame} est une liste de classe
  \index{data.frame}\code{"data.frame"} dont tous les éléments
  sont de la même longueur (ou comptent le même nombre de lignes si
  les éléments sont des matrices).
\item Il est généralement représenté sous la forme d'un tableau à deux
  dimensions. Chaque élément de la liste sous-jacente correspond à une
  colonne.
\item Bien que visuellement similaire à une matrice un \emph{data
    frame} est plus général puisque les colonnes peuvent être de modes
  différents; pensons à un tableau avec des noms (mode
  \code{character}) dans une colonne et des notes (mode
  \code{numeric}) dans une autre.
\item On crée un \emph{data frame} avec la fonction
  \Icode{data.frame} ou, pour convertir un autre type d'objet en
  \emph{data frame}, avec \Icode{as.data.frame}.
\item Le \emph{data frame} peut être indicé à la fois comme une liste
  et comme une matrice.
\item Les fonctions \icode{rbind} et \icode{cbind} peuvent être
  utilisées pour ajouter des lignes ou des colonnes à un \emph{data
    frame}.
\item On peut rendre les colonnes d'un \emph{data frame} (ou d'une
  liste) visibles dans l'espace de travail avec la fonction
  \Icode{attach}, puis les masquer avec \Icode{detach}.
\end{itemize}


%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
