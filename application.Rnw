%%% Copyright (C) 2017 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet «Programmer avec R»
%%% http://github.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition selon le contrat
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% http://creativecommons.org/licenses/by-sa/4.0/

\chapter{Structures de contrôle et fonctions d'application}
\label{chap:application}

<<echo=FALSE>>=
options(width=52)
@

\begin{objectifs}
\item Utiliser la fonction \code{if} pour l’exécution conditionnelle
  d'expressions R.
\item Concevoir une boucle dans R.
\item Choisir entre les opérateurs \code{for}, \code{while} et
  \code{repeat} lors de la construction d'une boucle R.
\item Effectuer des sommaires sur des tableaux à l’aide de la fonction
  \code{apply}.
\item Réduire des vecteurs et des listes avec les fonctions
  \code{lapply}, \code{sapply} et \code{mapply}; comparer l'effet de
  ces fonctions.
\item Passer des valeurs à une fonction d'application via l’argument
  `\code{...}'.
\item Distinguer la construction \code{if ... else ...} de la fonction
  \code{ifelse}.
\end{objectifs}

- Intro: définition structure de contrôle, repéter des calculs, choisir entre des options et contrôle le
flux d'un programme; applicatio
- Exécution conditionnelle
  - if
  - switch
  - ifelse
- Boucles
  - for
  - while et repeat
  - break, next, return
  - stop, warning
- Récursivité
- Exemple: suite de Fibonacci/Syndrôme de la plaque à biscuits
- Produit extérieur


Comme bien d'autres machines conçues par les humains, les ordinateurs
ont toujours été mis à contribution pour les tâches répétitives et
fastidieuses. Ce n'est donc pas pour rien que tous les langages de
programmation prévoient un ou plusieurs mécanismes pour répéter une
procédure un certain nombre de fois ou jusqu'à ce qu'une condition
soit remplie.

La répétition de procédures, la sortie forcée d'un programme ou le
choix entre diverses procédures sont réalisés à l'aide de commandes
spéciales appelées \emph{structures de contrôle}. Ce chapitre étudie
en premier lieu les structures de contrôle disponibles dans le langage
R.

Nous savons déjà que certains types de calculs répétitifs sont
automatiquement pris en charge par le langage R via une couche
d'abstraction que nous avons appelée l'arithmétique vectorielle
(\autoref{sec:bases:vecteurs:arithmetique}). Un autre large pan des
calculs répétitifs peut être réduit à quelques fonctions abstraites
dites d'\emph{application} (\emph{mapping}, un autre concept hérité du
\index{Lisp}Lisp). Les fonctions d'application masquent efficacement
les calculs répétitifs sur les dimensions des matrices et des
tableaux, ainsi que ceux sur les éléments d'un vecteur ou d'une liste.


\section{Exécution conditionnelle}
\label{sec:application:if}

Les premières structures de contrôle que nous étudions sont les
structures d'exécution conditionnelle. La plupart des programmes
doivent pouvoir effectuer des tests pour choisir entre deux actions
possibles ou plus. Par exemple, le programme pourrait s'arrêter avec
un message d'erreur si les arguments fournis par l'utilisateur ne sont
pas valides, effectuer des calculs différents selon la valeur d'un
argument, ou retourner un résultat prédéfini si un argument satisfait
certaines conditions.

La structure \Indexcode{if}\Indexcode{else}\code{if ... else ...}
permet d'exécuter une expression ou une autre selon qu'une condition
est vraie ou fausse. La clause alternative est optionnelle. Les
syntaxes des deux formulations sont les suivantes:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
if (\meta{condition})
    \meta{conséquence}
\end{Verbatim}
\end{Schunk}

\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
if (\meta{condition})
    \meta{conséquence}
else
    \meta{alternative}
\end{Verbatim}
\end{Schunk}

\begin{itemize}
\item \meta{condition} est une expression dont le résultat
  est une valeur \code{TRUE} ou \code{FALSE} \emph{unique}. C'est une
  erreur fréquente de construire des tests où \meta{condition} est un
  vecteur, ce qui n'a guère de sens. Les fonctions \icode{any},
  \icode{all} \autoref{sec:internes:fonctions:tests} et \icode{isTRUE}
  se révèlent utiles dans les clauses \code{if} pour réduire les
  vecteurs booléens à une valeur unique.
\item \meta{conséquence} est une expression, ou un groupe
  d'expressions regroupées entre accolades \verb={ }=, qui sont
  exécutées lorsque \meta{condition} est \texttt{TRUE}.
\item \meta{alternative} est une expression, ou un groupe
  d'expressions regroupées entre accolades \verb={ }=, qui sont
  exécutées lorsque \meta{condition} est \texttt{FALSE}.
\end{itemize}

\warningbox{Il tombe sous le sens que «vrai» est vrai, n'est-ce pas?
  Prenez donc garde de ne pas écrire des expressions qui reviennent à
  tester \verb|if (TRUE == TRUE)|. Oui, nous avons souvent rencontré
  de telles constructions!}

Pour choisir entre plus de deux possibilités, il est possible
d'emboiter des structures \code{if ... else ...} les unes dans les
autres.
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
if (\meta{condition 1})
    \meta{conséquence 1}
else if (\meta{condition 2})
    \meta{conséquence 2}
else
    \meta{alternative}
\end{Verbatim}
\end{Schunk}

Au-delà de trois ou quatre possibilités, il vaut souvent mieux
utiliser la fonction \Icode{switch}. Sa syntaxe est la suivante:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
switch(\meta{expression}, \meta{cas.1} = \meta{action.1},
                          \meta{cas.2} = \meta{action.2}, ...)
\end{Verbatim}
\end{Schunk}
La fonction évalue d'abord \meta{expression}. Si le résultat est une
valeur numérique $j$, alors \meta{action.$j$} est exécutée. Si le
résultat de \meta{expression} est l'une des chaines de caractères
\meta{cas.1}, \meta{cas.2}, \dots, alors c'est l'action correspondante
qui est exécutée.
<<echo=TRUE>>=
switch(2, 2 + 3, mean(1:10), 5:1)
switch("foo", foo = 2 + 3, bar = mean(1:10))
@

Enfin, la fonction \Icode{ifelse} --- une sorte de version vectorielle
de la structure \code{if ... else ...} --- permet de calculer des
valeurs selon les résultats d'un test sur un vecteur. Sa syntaxe est
la suivante:
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
ifelse(\meta{test}, \meta{oui}, \meta{non})
\end{Verbatim}
\end{Schunk}
Les arguments \meta{test}, \meta{oui} et \meta{non} sont trois
vecteurs de la même longueur
\begin{itemize}
\item \meta{test} est un vecteur booléen.
\item \meta{oui} est un vecteur duquel sont extraites les valeurs
  correspondant à des éléments \code{TRUE} dans \emta{test}.
\item \meta{non} est un vecteur duquel sont extraites les valeurs
  correspondant à des éléments \code{FALSE} dans \emta{test}.
\end{itemize}
<<echo=TRUE>>=
x <- c(-2, 3, -1, 0, 5, 1)
ifelse(x < 0, -x, x)
@

Une fois que l'on a compris son fonctionnement, la fonction
\icode{ifelse} peut apparaitre comme un outil de choix dans notre
arsenal de fonctions R, en particulier pour la programmation de
fonctions mathématiques définies par branches. En réalité, cependant,
\code{ifelse} est très lente. Dans la plupart des cas, il vaut mieux
lui préférer des constructions moins élégantes, mais bien plus
rapides. En particulier, la rubrique d'aide de la fonction souligne
que la structure \code{if ... else ...} est beaucoup plus efficace si
\meta{test} est un vecteur de longueur $1$.


\section{Boucles itératives}
\label{sec:internes:boucles}





\subsection{}



\begin{struclist}
\item[\fbox{for (\emph{variable} in \emph{suite}) \emph{expression}}]
  \rule{0em}{2.5ex}%
  \Indexfonction{for}%
  Exécuter \code{\emph{expression}} successivement pour chaque valeur
  de \code{\emph{variable}} contenue dans \code{\emph{suite}}.  Encore
  ici, on groupera les expressions dans des accolades \verb={ }=. À
  noter que \code{\emph{suite}} n'a pas à être composée de nombres
  consécutifs, ni même de nombres, en fait.
\item[\fbox{while (\emph{condition}) \emph{expression}}]
  \rule{0em}{2.5ex}%
  \Indexfonction{while}%
  Exécuter \code{\emph{expression}} tant que \code{\emph{condition}}
  est vraie. Si \code{\emph{condition}} est fausse lors de l'entrée
  dans la boucle, celle-ci n'est pas exécutée. Une boucle \code{while}
  n'est par conséquent pas nécessairement toujours exécutée.
\item[\fbox{repeat \emph{expression}}]
  \rule{0em}{2.5ex}%
  \Indexfonction{repeat}%
  Répéter \code{\emph{expression}}. Cette dernière devra comporter un
  test d'arrêt qui utilisera la commande \code{break}. Une boucle
  \code{repeat} est toujours exécutée au moins une fois.
\item[\fbox{break}]
  \rule{0em}{2.5ex}%
  \Indexfonction{break}%
  Sortie immédiate d'une boucle \code{for}, \code{while} ou
  \code{repeat}.
\item[\fbox{next}]
  \rule{0em}{2.5ex}%
  \Indexfonction{next}%
  Passage immédiat à la prochaine itération d'une boucle \code{for},
  \code{while} ou \code{repeat}.
\end{struclist}


\section{Fonctions d'application}
\label{sec:application:apply}

Les \index{boucle}boucles sont et doivent être utilisées avec
parcimonie en R, car elles sont généralement inefficaces. Dans la
majeure partie des cas, il est possible de vectoriser les calculs pour
éviter les boucles explicites, ou encore de s'en remettre aux
fonctions \fonction{outer}, \fonction{apply}, \fonction{lapply}
\fonction{sapply} et \fonction{mapply} (\autoref{avance:apply}) pour
réaliser les boucles de manière plus efficace.



\section{Produit extérieur}
\label{sec:internes:outer}

La %
\capsule{https://youtu.be/outer}{fonction \code{outer}}%
\Indexcode{outer} %
calcule le \index{produit!extérieur}produit extérieur entre deux
vecteurs. Ce n'est pas la fonction la plus intuitive à utiliser, mais
elle s'avère extrêmement utile pour effectuer plusieurs opérations en
une seule expression tout en évitant les boucles.

La syntaxe de \code{outer} est:
\begin{quote}
  \code{outer(X, Y, FUN)}
\end{quote}
Le résultat est l'application la fonction \code{FUN} (\fonction{"*"}
par défaut) entre chacun des éléments de \code{X} et chacun des
éléments de \code{Y}, autrement dit
\begin{quote}
  \code{FUN(X[i], Y[j])}
\end{quote}
pour toutes les valeurs des indices \code{i} et \code{j}.

\begin{itemize}
\item La dimension du résultat est par conséquent \code{c(dim(X),
    dim(Y))}.
\item Par exemple, le résultat du produit extérieur entre
  deux vecteurs est une matrice contenant tous les produits entre les
  éléments des deux vecteurs:
<<echo=TRUE>>=
outer(c(1, 2, 5), c(2, 3, 6))
@
\item Lorsque \code{FUN} est un opérateur arithmétique du
  \autoref{tab:internes:operateurs}, on place le symbole entre
  guillemets: \code{"*"}, \code{"+"}, \code{"<="}, etc.
\item L'opérateur \Icode{\%o\%} est un raccourci de \code{outer(X,
    Y, "*")}.
\end{itemize}




%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
