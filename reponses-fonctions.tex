\section*{Chapitre \ref{fonctions}}
\begin{reponse}{5.1}
\begin{verbatim}
variance <- function(x, biased=FALSE)
{
    if (biased)
    {
        n <- length(x)
        (n - 1)/n * var(x)
    }
    else
        var(x)
}
\end{verbatim}
  
\end{reponse}
\begin{reponse}{5.2}
    Une premi^^e8re solution utilise la transpos^^e9e. La premi^^e8re
    expression de la fonction s'assure que la longueur de
    \code{data} est compatible avec le nombre de lignes et de
    colonnes de la matrice demand^^e9e.
\begin{verbatim}
matrix2 <- function(data=NA, nrow=1, ncol=1,
                    bycol=FALSE, dimnames=NULL)
{
    data <- rep(data, length=nrow * ncol)

    if (bycol)
        dim(data) <- c(nrow, ncol)
    else
    {
        dim(data) <- c(ncol, nrow)
        data <- t(data)
    }

    dimnames(data) <- dimnames
    data
}
\end{verbatim}
    La seconde solution n'a pas recours ^^e0 la transpos^^e9e. Si l'on doit
    remplir la matrice par ligne, l'id^^e9e consiste ^^e0 r^^e9ordonner les
    ^^e9l^^e9ments du vecteur \code{data} en utilisant la formule obtenue
    ^^e0 l'exercice \ref{operateurs}.\ref{exercice:operateurs:ijk}.
\begin{verbatim}
matrix2 <- function(data=NA, nrow=1, ncol=1,
                    bycol=FALSE, dimnames=NULL)
{
    data <- rep(data, length=nrow * ncol)

    if (!bycol)
    {
        i <- 1:nrow
        j <- rep(1:ncol, each=nrow)
        data <- data[(i - 1)*ncol + j]
    }
    dim(data) <- c(nrow, ncol)
    dimnames(data) <- dimnames
    data
}
\end{verbatim}
  
\end{reponse}
\begin{reponse}{5.3}
\begin{verbatim}
phi <- function(x)
{
    exp(-x^2/2) / sqrt(2 * pi)
}
\end{verbatim}
  
\end{reponse}
\begin{reponse}{5.4}
\begin{verbatim}
Phi <- function(x)
{
    n <- 1 + 2 * 0:50
    0.5 + phi(x) * sum(x^n / cumprod(n))
}
\end{verbatim}
  
\end{reponse}
\begin{reponse}{5.5}
    Premi^^e8re solution utilisant une fonction interne et une structure
    de contr^^f4le \code{if ... else}.
\begin{verbatim}
Phi <- function(x)
{
    fun <- function(x)
    {
        n <- 1 + 2 * 0:50
        0.5 + phi(x) * sum(x^n / cumprod(n))
    }

    if (x < 0)
        1 - fun(-x)
    else
        fun(x)
}
\end{verbatim}
    Seconde solution r^^e9cursive, c'est-^^e0-dire que si $x < 0$, la
    fonction s'appelle elle-m^^eame avec un argument positif.
\begin{verbatim}
Phi <- function(x)
{
    if (x < 0)
        1 - Recall(-x)
    else
    {
        n <- 1 + 2 * 0:50
        0.5 + phi(x) * sum(x^n / cumprod(n))
    }
}
\end{verbatim}
    Troisi^^e8me solution sans structure de contr^^f4le \code{if ...
      else}. Rappelons que dans des calculs alg^^e9briques,
    \code{FALSE} vaut 0 et \code{TRUE} vaut 1.
\begin{verbatim}
Phi <- function(x)
{
    n <- 1 + 2 * 0:50
    neg <- x < 0
    x <- abs(x)
    neg + (-1)^neg * (0.5 + phi(x) *
                      sum(x^n / cumprod(n)))
}
\end{verbatim}
  
\end{reponse}
\begin{reponse}{5.6}
\begin{verbatim}
Phi <- function(x)
{
    n <- 1 + 2 * 0:30
    0.5 + phi(x) * colSums(t(outer(x, n, "^")) /
                           cumprod(n))
}
\end{verbatim}
  
\end{reponse}
\begin{reponse}{5.7}
    \begin{enumerate}
    \item
\begin{verbatim}
prod.mat <- function(mat1, mat2)
{
    if (ncol(mat1) == nrow(mat2))
    {
        res <- matrix(0, nrow=nrow(mat1),
                      ncol=ncol(mat2))
        for (i in 1:nrow(mat1))
        {
            for (j in 1:ncol(mat2))
            {
                res[i, j] <- sum(mat1[i,] * mat2[,j])
            }
        }
        res
    }
    else
        stop("Les dimensions des matrices ne
permettent pas le produit matriciel.")
}
\end{verbatim}
    \item
\begin{verbatim}
prod.mat<-function(mat1, mat2)
{
    if (ncol(mat1) == nrow(mat2))
    {
        res <- matrix(0, nrow=nrow(mat1),
                      ncol=ncol(mat2))
        for (i in 1:nrow(mat1))
            res[i,] <- colSums(mat1[i,] * mat2)
        res
    }
    else
        stop("Les dimensions des matrices ne
permettent pas le produit matriciel.")
}
\end{verbatim}
    \end{enumerate}
    Solutions bonus: deux fa^^e7ons de faire ^^e9quivalentes qui cachent la
    boucle dans un \fonction{sapply}.
\begin{verbatim}
prod.mat<-function(mat1, mat2)
{
    if (ncol(mat1) == nrow(mat2))
        t(sapply(1:nrow(mat1),
                 function(i) colSums(mat1[i,] * mat2)))
    else
        stop("Les dimensions des matrices ne permettent
pas le produit matriciel.")
}

prod.mat<-function(mat1, mat2)
{
    if (ncol(mat1) == nrow(mat2))
        t(sapply(1:ncol(mat2),
                 function(j) colSums(t(mat1) * mat2[,j])))
    else
        stop("Les dimensions des matrices ne permettent
pas le produit matriciel.")
}
\end{verbatim}
  
\end{reponse}
\begin{reponse}{5.8}
\begin{verbatim}
notes.finales <- function(notes, p) notes %*% p
\end{verbatim}
  
\end{reponse}
\begin{reponse}{5.10}
\begin{verbatim}
param <- function (moyenne, variance, loi)
{
    loi <- tolower(loi)
    if (loi == "normale")
    {
        param1 <- moyenne
        param2 <- sqrt(variance)
        return(list(mean=param1, sd=param2))
    }
    if (loi == "gamma")
    {
        param2 <- moyenne/variance
        param1 <- moyenne * param2
        return(list(shape=param1, scale=param2))
    }
    if (loi == "pareto")
    {
        cte <- variance/moyenne^2
        param1 <- 2 * cte/(cte-1)
        param2 <- moyenne * (param1 - 1)
        return(list(alpha=param1, lambda=param2))
    }
    stop("La loi doit etre une de \"normale\",
\"gamma\" ou \"pareto\"")
}
\end{verbatim}
  
\end{reponse}
