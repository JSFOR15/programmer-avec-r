%%% Copyright (C) 2017 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet «Programmer avec R»
%%% http://github.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition selon le contrat
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% http://creativecommons.org/licenses/by-sa/4.0/

\chapter{Fonctions internes utiles et extensions}
\label{chap:internes}

<<echo=FALSE>>=
options(width=52)
@

\begin{objectifs}
\item Utiliser les fonctions R les plus courantes, notamment pour le
  traitement des vecteurs, le calcul de sommaires et la manipulation
  des matrices et des tableaux.
\item Distinguer les concepts de paquetage et de bibliothèque dans R.
\item Utiliser les fonctionnalités d'un paquetage dans une session de
  travail R.
\item Installer de nouveaux paquetages R depuis le site
  \emph{Comprehensive R Archive Network} (CRAN).
\end{objectifs}

Ce chapitre présente les principaux opérateurs arithmétiques,
fonctions mathématiques et structures de contrôle disponibles dans R.
La liste est évidemment loin d'être exhaustive, surtout étant donné
l'évolution rapide du langage. Un des meilleurs endroits pour
découvrir de nouvelles fonctions demeure la section \texttt{See Also}
des rubriques d'aide, qui offre des hyperliens vers des fonctions
apparentées au sujet de la rubrique.


Le langage R compte un très grand nombre (des milliers!) de fonctions
internes. Cette section en présente quelques-unes seulement, les
fonctions de base les plus souvent utilisées pour programmer en R et
pour manipuler des données.

Pour chaque fonction présentée dans les sections suivantes, on fournit
un ou deux exemples d'utilisation. Ces exemples sont souvent loin de
courvrir toutes les utilisations possibles d'une fonction. La
\autoref{internes:exemples} fournit des exemples additionnels,
mais il est recommandé de consulter les diverses rubriques d'aide pour
connaître toutes les options des fonctions.


\section{Opérateurs}
\label{internes:operateurs}

Nous avons déjà présenté au \autoref{tab:bases:operateurs} les
opérateurs mathématiques et logiques les plus fréquemment employés, en
ordre décroissant de priorité des opérations.

\tipbox{Les opérateurs de puissance \verb|^| et d'affectation
  \icode{<-} sont évalués de droite à gauche; tous les autres le sont
  de gauche à droite. Ainsi, \verb|2^2^3| est \verb|2^8|, et non
  \verb|4^3|, alors que \verb|1 - 1 - 1| vaut \verb|-1|, et non
  \verb|1|.}

\begin{ttscript}{\%/\%}
\item[\code{\%\%}] modulo (reste d'une division)
<<echo=TRUE>>=
5 %% 3
@
\item[\code{\%/\%}] division entière (partie entière d'une division)
<<echo=TRUE>>=
5 %/% 3
@
\end{ttscript}

%%%%!!!!! On a toujours x = (x %/% y) * y + x %% y


\section{Manipulation de vecteurs}
\label{internes:vecteurs}

%%% Modification des environnements de code pour rendre les exemples
%%% plus compacts.
\fvset{listparameters={\setlength{\topsep}{\compactsep}}}
\begin{ttscript}{seqmalong}
\item[\Icode{seq}] suite de nombres générale
<<echo=TRUE>>=
seq(1, 9, by = 2)
@
\item[\Icode{\protect seq\_len}] \index{suite}suite de nombres de $1$
  à la valeur de l'argument (plus rapide que \code{seq})
<<echo=TRUE>>=
seq_len(10)
@
\item[\Icode{\protect seq\_along}] suite de nombres de la longueur de
  l'argument à partir de $1$ (plus rapide que \code{seq})
<<echo=TRUE>>=
seq_len(10)
@
\item[\Icode{rep}] \index{repetition@répétition}répétition de valeurs
  ou de vecteurs
<<echo=TRUE>>=
rep(2, 10)
@
\item[\Icode{sort}] \index{tri}tri en ordre croissant ou
  décroissant
<<echo=TRUE>>=
sort(c(4, -1, 2, 6))
@
\item[\Icode{rank}] \index{rang}rang des éléments d'un vecteur dans
  l'ordre croissant ou décroissant
<<echo=TRUE>>=
rank(c(4, -1, 2, 6))
@
\item[\href{https://youtu.be/order}{\Icode{order}}]
  \index{ordre}ordre \capsule{https://youtu.be/order}{} d'extraction
  des éléments d'un vecteur pour les placer en ordre croissant ou
  décroissant
<<echo=TRUE>>=
order(c(4, -1, 2, 6))
@
\item[\Icode{rev}] vecteur \index{renverser}renversé
<<echo=TRUE>>=
rev(1:10)
@
\item[\Icode{head}] $n$ premiers éléments d'un vecteur (ou lignes
  d'une matrice ou d'un \emph{data frame}) si $n > 0$, ou vecteur sans
  les $n$ derniers éléments si $n < 0$
<<echo=TRUE>>=
head(1:10, 3)
head(1:10, -3)
@
\item[\Icode{tail}] $n$ derniers éléments d'un vecteur (ou lignes
  d'une matrice ou d'un \emph{data frame}) si $n > 0$, ou vecteur sans
  les $n$ premiers éléments si $n < 0$
<<echo=TRUE>>=
tail(1:10, 3); tail(1:10, -3)
@
\item[\Icode{unique}] éléments uniques d'un vecteur
<<echo=TRUE>>=
unique(c(2, 4, 2, 5, 9, 5, 0))
@
\end{ttscript}

%\fvset{listparameters={\setlength{\topsep}{\normalsep}}}


\subsection{Recherche d'éléments dans un vecteur}

Les fonctions de cette sous-section sont toutes illustrées avec le vecteur
<<echo=FALSE>>=
x <- c(4, -1, 2, -3, 6)
@
<<echo=TRUE>>=
x
@

\fvset{listparameters={\setlength{\topsep}{\compactsep}}}
\begin{ttscript}{which.max}
\item[\Icode{which}] positions des valeurs \texttt{TRUE} dans un vecteur
  booléen
<<echo=TRUE>>=
which(x < 0)
@
\item[\Icode{which.min}] position du minimum\index{minimum!position
    dans un vecteur} dans un vecteur
<<echo=TRUE>>=
which.min(x)
@
\item[\Icode{which.max}] position du maximum\index{maximum!position
    dans un vecteur} dans un vecteur
<<echo=TRUE>>=
which.max(x)
@
\item[\Icode{match}] position de la première occurrence d'un élément dans un
  vecteur
<<echo=TRUE>>=
match(2, x)
@
\item[\Icode{\%in\%}] appartenance d'une ou plusieurs valeurs à un vecteur
<<echo=TRUE>>=
-1:2 %in% x
@
\end{ttscript}
\fvset{listparameters={\setlength{\topsep}{\normalsep}}}


\subsection{Arrondi}

Les fonctions de cette sous-section sont toutes illustrées avec le vecteur
<<echo=FALSE>>=
x <- c(-3.68, -2/3, pi, 1/3, 2.52)
@
<<echo=TRUE>>=
x
@

\fvset{listparameters={\setlength{\topsep}{\compactsep}}}
\begin{ttscript}{ceiling}
\item[\Icode{round}] arrondi\index{arrondi} à un nombre défini de
  décimales (par défaut $0$)
<<echo=TRUE>>=
round(x)
round(x, 3)
@

\item[\Icode{floor}] plus grand entier inférieur ou égal à l'argument
<<echo=TRUE>>=
floor(x)
@

\item[\Icode{ceiling}] plus petit entier supérieur ou égal à l'argument
<<echo=TRUE>>=
ceiling(x)
@

\item[\Icode{trunc}] troncature vers zéro; différent de
  \texttt{floor} pour les nombres négatifs
<<echo=TRUE>>=
trunc(x)
@
\end{ttscript}
\fvset{listparameters={\setlength{\topsep}{\normalsep}}}


\subsection{Sommaires et statistiques descriptives}

Les fonctions de cette sous-section sont toutes illustrées avec le vecteur
<<echo=FALSE>>=
x <- c(14, 17, 7, 9, 3, 4, 25, 21, 24, 11)
@
<<echo=TRUE>>=
x
@

\fvset{listparameters={\setlength{\topsep}{\compactsep}}}
\begin{ttscript}{sum, prod}
\item[\Icode{sum}, \Icode{prod}] somme\index{somme} et
  produit\index{produit} des éléments d'un vecteur
<<echo=TRUE>>=
sum(x); prod(x)
@
\item[\Icode{diff}] différences\index{différences} entre les
  éléments d'un vecteur (opérateur mathématique $\nabla$)
<<echo=TRUE>>=
diff(x)
@
\item[\Icode{mean}] moyenne
  arithmétique\index{moyenne!arithmétique} (et moyenne
  tronquée\index{moyenne!tronquée} avec l'argument \code{trim})
<<echo=TRUE>>=
mean(x)
@
\item[\Icode{var}, \Icode{sd}] variance\index{variance} et écart
  type\index{ecart type@écart type} (versions sans biais)
<<echo=TRUE>>=
var(x)
@
\item[\Icode{min}, \Icode{max}] minimum\index{minimum!d'un
    vecteur} et maximum\index{maximum!d'un vecteur} d'un vecteur
<<echo=TRUE>>=
min(x); max(x)
@
\item[\Icode{range}] vecteur contenant le minimum et le maximum
  d'un vecteur
<<echo=TRUE>>=
range(x)
@
\item[\Icode{median}] médiane\index{mediane@médiane} empirique
<<echo=TRUE>>=
median(x)
@
\item[\Icode{quantile}] quantiles\index{quantile} empiriques
<<echo=TRUE>>=
quantile(x)
@
\item[\Icode{summary}] statistiques descriptives d'un échantillon
<<echo=TRUE>>=
summary(x)
@
\end{ttscript}
\fvset{listparameters={\setlength{\topsep}{\normalsep}}}




\subsection{Sommaires cumulatifs et comparaisons élément par élément}

Les fonctions de cette sous-section sont toutes illustrées avec le vecteur
<<echo=FALSE>>=
x <- c(14, 17, 7, 9, 3)
@
<<echo=TRUE>>=
x
@

\fvset{listparameters={\setlength{\topsep}{\compactsep}}}
\begin{ttscript}{cumsum, cumprod}
\item[\Icode{cumsum}, \Icode{cumprod}]
  somme\index{somme!cumulative} et produit\index{produit!cumulatif}
  cumulatif d'un vecteur
<<echo=TRUE>>=
cumsum(x); cumprod(x)
@
\item[\Icode{cummin}, \Icode{cummax}]
  minimum\index{minimum!cumulatif} et maximum\index{maximum!cumulatif}
  cumulatif
<<echo=TRUE>>=
cummin(x); cummax(x)
@
\item[\Icode{pmin}, \Icode{pmax}]
  minimum\index{minimum!parallèle} et maximum\index{maximum!parallèle}
  élément par élément (en parallèle) entre deux vecteurs ou plus
<<echo=TRUE>>=
pmin(x, 12)
pmax(x, c(16, 23,  4, 12,  3))
@
\end{ttscript}
\fvset{listparameters={\setlength{\topsep}{\normalsep}}}


\subsection{Opérations sur les matrices}

Les fonctions de cette sous-section sont toutes illustrées avec la matrice
<<echo=FALSE>>=
x <- matrix(c(2, 1, 4, 3), 2)
@
<<echo=TRUE>>=
x
@

\fvset{listparameters={\setlength{\topsep}{\compactsep}}}
\begin{ttscript}{rowMeans, colMeans}
\item[\code{\%*\%}] produit matriciel



\item[\Icode{nrow}, \Icode{ncol}] nombre de lignes et de
  colonnes d'une matrice
<<echo=TRUE>>=
nrow(x); ncol(x)
@
\item[\Icode{rowSums}, \Icode{colSums}]
  sommes\index{matrice!sommes par ligne} par ligne et par
  colonne\index{matrice!somme par colonne}, respectivement, des
  éléments d'une matrice; voir aussi la fonction \texttt{apply} à la
  \autoref{avance:apply}
<<echo=TRUE>>=
rowSums(x)
@
\item[\Icode{rowMeans}, \Icode{colMeans}]
  moyennes\index{matrice!moyennes par ligne} par ligne et par
  colonne\index{matrice!moyennes par colonne}, respectivement, des
  éléments d'une matrice; voir aussi la fonction \texttt{apply} à la
  \autoref{avance:apply}
<<echo=TRUE>>=
colMeans(x)
@
\item[\Icode{t}] transposée\index{matrice!transposée}
<<echo=TRUE>>=
t(x)
@
\item[\Icode{det}] déterminant
<<echo=TRUE>>=
det(x)
@
\item[\Icode{solve}]
  \begin{inparaenum}[1)]
  \item avec un seul argument (une matrice carrée):
    inverse\index{matrice!inverse} d'une matrice;
  \item avec deux arguments (une matrice carrée et un vecteur):
    solution du système d'équations linéaires $\mat{A} \mat{x} =
    \mat{b}$
  \end{inparaenum}

<<echo=TRUE>>=
solve(x)
solve(x, c(1, 2))
@
\item[\Icode{diag}]
  \begin{inparaenum}[1)]
  \item avec une matrice en argument: diagonale de la matrice;
  \item avec un vecteur en argument: matrice
    diagonale\index{matrice!diagonale} formée avec le vecteur;
  \item avec un scalaire $p$ en argument: matrice
    identité\index{matrice!identité} $p \times p$
  \end{inparaenum}
<<echo=TRUE>>=
diag(x)
@
\end{ttscript}
\fvset{listparameters={\setlength{\topsep}{\normalsep}}}


\subsection{Produit extérieur}
\index{produit!extérieur}

La %
\capsule{https://youtu.be/outer}{fonction \code{outer}}%
\Indexfonction{outer} %
calcule le produit extérieur entre deux vecteurs. Ce n'est pas la
fonction la plus intuitive à utiliser, mais elle s'avère extrêmement
utile pour faire plusieurs opérations en une seule expression tout en
évitant les boucles. La syntaxe de \fonction{outer} est:
\begin{quote}
  \code{outer(X, Y, FUN)}
\end{quote}
Le résultat est l'application la fonction \code{FUN} (\fonction{"*"}
par défaut) entre chacun des éléments de \code{X} et chacun des
éléments de \code{Y}, autrement dit
\begin{quote}
  \code{FUN(X[i], Y[j])}
\end{quote}
pour toutes les valeurs des indices \code{i} et \code{j}.

\begin{itemize}
\item La dimension du résultat est par conséquent \code{c(dim(X),
    dim(Y))}.
\item Par exemple, le résultat du produit extérieur entre
  deux vecteurs est une matrice contenant tous les produits entre les
  éléments des deux vecteurs:
<<echo=TRUE>>=
outer(c(1, 2, 5), c(2, 3, 6))
@
\item Lorsque \code{FUN} est un opérateur arithmétique du
  \autoref{tab:internes:operateurs}, on place le symbole entre
  guillemets: \code{"*"}, \code{"+"}, \code{"<="}, etc.
\item L'opérateur \Icode{\%o\%} est un raccourci de \code{outer(X,
    Y, "*")}.
\end{itemize}




\section{Structures de contrôle}
\label{internes:structures}

Les structures de contrôle sont des commandes qui permettent de
déterminer le flux d'exécution d'un programme: choix entre des blocs
de code, répétition de commandes ou sortie forcée.

On se contente, ici, de mentionner les structures de contrôle
disponibles en R. La \autoref{internes:exemples} fournit des
exemples d'utilisation.

\subsection{Exécution conditionnelle}

\begin{struclist}
\item[\fbox{if (\emph{condition}) \emph{branche.vrai} else
    \emph{branche.faux}}] %
  \rule{0em}{2.5ex}%
  \Indexfonction{if}%
  \Indexfonction{else}%
  \sloppy Si \code{\emph{condition}} est vraie,
  \code{\emph{branche.vrai}} est exécutée, sinon ce sera
  \code{\emph{branche.faux}}. Dans le cas où l'une ou l'autre de
  \code{\emph{branche.vrai}} ou \code{\emph{branche.faux}} comporte
  plus d'une expression, regrouper celles-ci dans des accolades
  \verb={ }=.
\item[\fbox{ifelse(\emph{condition}, \emph{expression.vrai},
    \emph{expression.faux})}] %
  \rule{0em}{2.5ex}%
  \Indexfonction{ifelse}%
  Fonction vectorielle qui retourne un vecteur de la même longueur que
  \code{\emph{condition}} formé ainsi: pour chaque élément \code{TRUE}
  de \code{\emph{condition}} on choisit l'élément correspondant de
  \code{\emph{expression.vrai}} et pour chaque élément \code{FALSE}
  on choisit l'élément correspondant de \code{\emph{expression.faux}}.
  L'utilisation n'est pas très intuitive, alors examiner attentivement
  les exemples de la rubrique d'aide.
\item[\fbox{switch(\emph{test}, \emph{cas.1 = action.1}, \emph{cas.2 =
      action.2}, ...)}] %
  \rule{0em}{2.5ex}%
  \Indexfonction{switch}%
  Structure utilisée plutôt rarement. Consulter la rubrique d'aide au
  besoin.
\end{struclist}

\subsection{Boucles}

Les boucles\index{boucle} sont et doivent être utilisées avec
parcimonie en R, car elles sont généralement inefficaces. Dans la
majeure partie des cas, il est possible de vectoriser les calculs pour
éviter les boucles explicites, ou encore de s'en remettre aux
fonctions \fonction{outer}, \fonction{apply}, \fonction{lapply}
\fonction{sapply} et \fonction{mapply} (\autoref{avance:apply})
pour réaliser les boucles de manière plus efficace.

\begin{struclist}
\item[\fbox{for (\emph{variable} in \emph{suite}) \emph{expression}}]
  \rule{0em}{2.5ex}%
  \Indexfonction{for}%
  Exécuter \code{\emph{expression}} successivement pour chaque valeur
  de \code{\emph{variable}} contenue dans \code{\emph{suite}}.  Encore
  ici, on groupera les expressions dans des accolades \verb={ }=. À
  noter que \code{\emph{suite}} n'a pas à être composée de nombres
  consécutifs, ni même de nombres, en fait.
\item[\fbox{while (\emph{condition}) \emph{expression}}]
  \rule{0em}{2.5ex}%
  \Indexfonction{while}%
  Exécuter \code{\emph{expression}} tant que \code{\emph{condition}}
  est vraie. Si \code{\emph{condition}} est fausse lors de l'entrée
  dans la boucle, celle-ci n'est pas exécutée. Une boucle \code{while}
  n'est par conséquent pas nécessairement toujours exécutée.
\item[\fbox{repeat \emph{expression}}]
  \rule{0em}{2.5ex}%
  \Indexfonction{repeat}%
  Répéter \code{\emph{expression}}. Cette dernière devra comporter un
  test d'arrêt qui utilisera la commande \code{break}. Une boucle
  \code{repeat} est toujours exécutée au moins une fois.
\item[\fbox{break}]
  \rule{0em}{2.5ex}%
  \Indexfonction{break}%
  Sortie immédiate d'une boucle \code{for}, \code{while} ou
  \code{repeat}.
\item[\fbox{next}]
  \rule{0em}{2.5ex}%
  \Indexfonction{next}%
  Passage immédiat à la prochaine itération d'une boucle \code{for},
  \code{while} ou \code{repeat}.
\end{struclist}


\section{Fonctions additionnelles}
\label{internes:packages}

La bibliothèque des fonctions internes de R est divisée en ensembles
de fonctions et de jeux de données apparentés nommés
\emph{packages}\Index{package} (terme que l'équipe de traduction
française de R a choisi de conserver tel quel). On démarrage, R charge
automatiquement quelques packages de la bibliothèque, ceux contenant
les fonctions les plus fréquemment utilisées. On peut voir la liste
des packages déjà en mémoire avec la fonction \Icode{search} et le
contenu de toute la bibliothèque avec la fonction \Icode{library}
(résultat non montré ici):
<<echo=TRUE>>=
search()
@

Une des grandes forces de R est la facilité avec laquelle on peut
ajouter des fonctionnalités au système par le biais de packages
externes. Dès les débuts de R, les développeurs et utilisateurs ont
mis sur pied le dépôt central de packages \emph{Comprehensive R
  Archive Network} (CRAN; \url{http://cran.r-project.org}). Ce site
compte aujourd'hui des milliers d'extensions et le nombre ne
cesse de croître.

Le système R rend simple le téléchargement et l'installation de nouveaux
packages avec la fonction \Icode{install.packages}.
L'\autoref{packages} explique plus en détails comment gérer sa
bibliothèque personnelle et installer des packages externes.



\section{Exemples}
\label{internes:exemples}

\lstinputlisting[firstline=3]{internes.R}


\section{Exercices}
\label{internes:exercices}

\Opensolutionfile{solutions}[solutions-operateurs]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{operateurs}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{operateurs}}

\end{Filesave}

\SweaveOpts{echo=FALSE,term=FALSE}
\begin{exercice}
  À l'aide des fonctions \fonction{rep}, \fonction{seq} et
  \code{c} seulement, générer les séquences suivantes.
  \begin{enumerate}
  \item
<<>>=
cat(rep(c(0, 6), 3))
@
  \item
<<>>=
cat(seq(1, 10, by = 3))
@
  \item
<<>>=
cat(rep(1:3, 4))
@
  \item
<<>>=
cat(rep(1:3, 1:3))
@
  \item
<<>>=
cat(rep(1:3, 3:1))
@
  \item
<<>>=
cat(seq(1, 10, length = 3))
@
  \item
<<>>=
cat(rep(1:3, rep(4, 3)))
@
  \end{enumerate}
  \SweaveOpts{echo=TRUE, eval=FALSE}
  \begin{sol}
    \begin{enumerate}
\item
<<>>=
rep(c(0, 6), 3)
@
\item
<<>>=
seq(1, 10, by = 3)
@
\item
<<>>=
rep(1:3, 4)
@
\item
<<>>=
rep(1:3, 1:3)
@
\item
<<>>=
rep(1:3, 3:1)
@
\item
<<>>=
seq(1, 10, length = 3)
@
\item
<<>>=
rep(1:3, rep(4,3))
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\SweaveOpts{echo=FALSE,eval=TRUE,term=FALSE}
\begin{exercice}
  Générer les suites de nombres suivantes à l'aide des fonctions
  {\NoAutoSpacing\verb=:=}\index{:@\verb=:=} et \texttt{rep} seulement, donc sans
  utiliser la fonction \fonction{seq}.
  \begin{enumerate}
  \item
<<>>=
cat(11:20 / 10)
@
  \item
<<>>=
cat(2 * 0:9 + 1)
@
  \item
<<>>=
cat(rep(-2:2, 2))
@
  \item
<<>>=
cat(rep(-2:2, each = 2))
@
  \item
<<>>=
cat(10 * 1:10)
@
  \end{enumerate}
  \SweaveOpts{echo=TRUE,eval=FALSE}
  \begin{sol}
    \begin{enumerate}
\item
<<>>=
11:20 / 10
@
\item
<<>>=
2 * 0:9 + 1
@
\item
<<>>=
rep(-2:2, 2)
@
\item
<<>>=
rep(-2:2, each = 2)
@
\item
<<>>=
10 * 1:10
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  À l'aide de la commande \fonction{apply}, écrire des expressions R
  qui remplaceraient les fonctions suivantes.
  \begin{enumerate}
  \item \fonction{rowSums}
  \item \fonction{colSums}
  \item \fonction{rowMeans}
  \item \fonction{colMeans}
  \end{enumerate}
  \begin{sol}
    Soit \code{mat} une matrice.
    \begin{enumerate}
\item
<<>>=
apply(mat, 1, sum)
@
\item
<<>>=
apply(mat, 2, sum)
@
\item
<<>>=
apply(mat, 1, mean)
@
\item
<<>>=
apply(mat, 2, mean)
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Sans utiliser les fonctions \fonction{factorial},
  \fonction{lfactorial}, \fonction{gamma} ou \fonction{lgamma},
  générer la séquence $1!, 2!, \dots, 10!$.
  \begin{sol}
<<>>=
cumprod(1:10)
@
  \end{sol}
\end{exercice}

\begin{exercice}
  Trouver une relation entre \code{x}, \code{y}, \code{x \%\% y}
  (modulo) et \code{x \%/\% y} (division entière), où \code{y != 0}.
  \begin{sol}
    \verb|x == (x %% y) + y * (x %/% y)|
  \end{sol}
\end{exercice}

%\enlargethispage{10mm}
\begin{exercice}
  Simuler un échantillon $\mat{x} = (x_1, x_2, x_3, ..., x_{20})$ avec
  la fonction \fonction{sample}.  Écrire une expression R permettant
  d'obtenir ou de calculer chacun des résultats demandés ci-dessous.
  \begin{enumerate}
  \item Les cinq premiers éléments de l'échantillon.
  \item La valeur maximale de l'échantillon.
  \item La moyenne des cinq premiers éléments de l'échantillon.
  \item La moyenne des cinq derniers éléments de l'échantillon.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<>>=
x[1:5]
head(x, 5)
@
\item
<<>>=
max(x)
@
\item
<<>>=
mean(x[1:5])
mean(head(x, 5))
@
\item
<<>>=
mean(x[16:20])
mean(x[(length(x) - 4):length(x)])  # plus général
mean(tail(x, 5))                    # plus lisible!
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  \label{exercice:internes:ijk}
  \begin{enumerate}
  \item Trouver une formule pour calculer la position, dans le vecteur
    sous-jacent, de l'élément $(i, j)$ d'une matrice\index{matrice} $I
    \times J$ remplie par colonne.
  \item Répéter la partie a) pour l'élément $(i, j, k)$ d'un
    tableau\index{tableau} $I \times J \times K$.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item \verb|(j - 1)*I + i|
    \item \verb|((k - 1)*J + j - 1)*I + i|
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  Simuler une matrice\index{matrice} \code{mat} $10 \times 7$, puis
  écrire des expressions R permettant d'effectuer les tâches demandées
  ci-dessous.
  \begin{enumerate}
  \item Calculer la somme des éléments de chacunes des lignes de la
    matrice.
  \item Calculer la moyenne des éléments de chacunes des colonnes de
    la matrice.
  \item Calculer la valeur maximale de la sous-matrice formée par les
    trois premières lignes et les trois premières colonnes.
  \item Extraire toutes les lignes de la matrice dont la moyenne des
    éléments est supérieure à $7$.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<>>=
rowSums(mat)
@
\item
<<>>=
colMeans(mat)
@
\item
<<>>=
max(mat[1:3, 1:3])
@
\item
<<>>=
mat[rowMeans(mat) > 7,]
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  On vous donne la liste et la date des 31 meilleurs temps enregistrés
  au 100~mètres homme entre 1964 et 2005:
<<echo=TRUE>>=
temps <- c(10.06, 10.03, 10.02,  9.95, 10.04, 10.07,
           10.08, 10.05,  9.98, 10.09, 10.01, 10.00,
            9.97,  9.93,  9.96,  9.99,  9.92,  9.94,
            9.90,  9.86,  9.88,  9.87,  9.85,  9.91,
            9.84,  9.89,  9.79,  9.80,  9.82,  9.78,
            9.77)
names(temps) <- c("1964-10-15", "1968-06-20",
    "1968-10-13", "1968-10-14", "1968-10-14",
    "1968-10-14", "1968-10-14", "1975-08-20",
    "1977-08-11", "1978-07-30", "1979-09-04",
    "1981-05-16", "1983-05-14", "1983-07-03",
    "1984-05-05", "1984-05-06", "1988-09-24",
    "1989-06-16", "1991-06-14", "1991-08-25",
    "1991-08-25", "1993-08-15", "1994-07-06",
    "1994-08-23", "1996-07-27", "1996-07-27",
    "1999-06-16", "1999-08-22", "2001-08-05",
    "2002-09-14", "2005-06-14")
@
  Extraire de ce vecteur les records du monde seulement, c'est-à-dire
  la première fois que chaque temps a été réalisé.
  \begin{sol}
<<>>=
temps[match(unique(cummin(tps)), temps)]
@
  \end{sol}
\end{exercice}

\Closesolutionfile{solutions}


%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
