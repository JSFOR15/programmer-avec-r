\chapter{Bases du langage R}
\label{chap:bases}

<<echo=FALSE>>=
options(width=52)
@

\begin{objectifs}
\item Écrire et interpréter la syntaxe et la sémantique du langage R.
\item Utiliser l'arithmétique vectorielle du langage R dans les
  calculs.
\item Créer et manipuler des vecteurs simples («atomiques»).
\item Utiliser les divers modes des vecteurs (en particulier
  \code{numeric}, \code{character} et \code{logical}) et la conversion
  automatique de l'un à l'autre.
\item Extraire des données d'un vecteur simple ou y affecter de
  nouvelles valeurs à l'aide des méthodes d'indiçage.
\item Appeler une fonction R; concevoir comment les arguments sont
  passés à la fonction et le traitement des valeurs par défaut.
\item Définir une fonction R, ses divers arguments et, le cas échéant,
  les valeurs par défaut de ceux-ci.
\item Utiliser et définir des fonctions R ayant un nombre variable
  d'arguments.
\end{objectifs}

C'est dans ce chapitre que nous débutons réellement l'apprentissage de
la programmation. Avouons-le d'entrée de jeu: notre présentation a
fortement été influencée par l'ouvrage magistral de
\cite{Sussman:scheme:1996}.

Les humains créent des programmes informatiques pour contrôler, à
l'aide d'un ensemble de règles, les processus de calcul et de
manipulation de données d'un ordinateur. Ces programmes sont rédigés
dans un langage de programmation.

Un langage est toutefois plus qu'une simple manière de transmettre des
instructions à un ordinateur, c'est aussi une façon de conceptualiser
les procédures que l'ordinateur devra effectuer. Autrement dit, le
type de langage de programmation que nous utilisons influence
directement la solution que nous proposerons à un problème --- et vice
versa. Comme nous l'avons déjà fait à la
\autoref{sec:informatique:semantique}, dressons un parallèle avec les
langues parlées et écrites: une langue ne constitue pas seulement un
moyen de transmettre une idée, mais bien une façon de concevoir le
monde. Ce n'est pas pour rien qu'il est parfois impossible de faire
passer une idée d'une langue vers une autre --- ce que l'on appelle
couramment une «expression intraduisible».

Le langage de programmation étudié ici est le R. Sa syntaxe, celle du
langage \index{S}S, s'apparente au \index{C}C. En revanche, la
sémantique de R s'inspire du paradigme de la programmation
fonctionnelle, ce qui lui confère de plus grandes affinités avec le
\index{Lisp}Lisp et \index{APL}l'APL.

Ce chapitre introduit des notions de base du langage R telles que
l'expression, l'affectation, et l'objet. Le concept de vecteur se
trouvant au cœur du langage, nous faisons une large place à la
création et à la manipulation des vecteurs. Le chapitre se termine par
la définition de fonctions.


\section{Données et procédures fondamentales}
\label{sec:bases:fondamentales}

À sa plus simple expression, la programmation est un exercice de
manipulation de \emph{données} à l'aide de \emph{procédures}. Un
langage de programmation fournit au programmeur des données et des
procédures fondamentales (ou \emph{génériques}), des manières de les
combiner pour former des éléments composés, ainsi qu'un mécanisme
d'abstraction permettant de nommer et de manipuler ces éléments
composés.

Les données fondamentales de R sont les suivantes:
\begin{itemize}
\item nombres réels: \code{0, 1, 2, 78.42, -1.39}, \dots;
\item chaines de caractères: \code{"a"}, \code{"abc"}, \dots;
\item valeurs booléennes: \Objet{TRUE}, \Objet{FALSE};
\item donnée manquante: \Objet{NA};
\item infini positif et négatif: \Objet{Inf}, \code{-Inf};
\item valeur indéterminée: \Objet{NaN};
\item «néant»: \Objet{NULL};
\item nombres complexes: \code{1 + 2i}.
\end{itemize}
La grande majorité des langages de programmation offrent les deux
premiers type de données ci-dessus. Les autres types se revèlent très
utiles pour la programmation mathématique et l'analyse de données.
Nous reviendrons sur leurs caractéristiques à la
\autoref{sec:bases:objets}.

Quant aux procédures fondamentales, nous pourrions les classer en
quatre grandes catégories:
\begin{itemize}
\item arithmétique: \verb|+ - * / ^ < >= ==|, etc.;
\item logique: \verb=& | !=\,;
\item indiçage: \verb=[ ] $=\,;
\item affectation: \verb|<-|\,.
\end{itemize}
Les opérations arithmétiques sont applicables aux nombres réels ou
complexes, alors que les opérations logiques ne sont applicables
qu'aux valeurs booléennes. Nous traitons de l'opération d'affectation
en détail à la section suivante.

Le \autoref{tab:bases:operateurs} présente les opérateurs les plus
fréquemment employés en ordre décroissant de priorité des opérations.
Ils sont accompagnés d'une description succincte. Nous reviendrons sur
certains opérateurs dans les chapitres subséquents.

\begin{table}
  \centering
  \renewcommand{\arraystretch}{1.1}
  \begin{tabular}{lp{8cm}}
    \toprule
    Opérateur     & Fonction \\
    \midrule
    \verb=$= & extraction \\
    \verb=[=\, \verb=[[= & indiçage \\
    \verb=^= & puissance \\
    \verb=-=  & changement de signe \\
    \verb=:=  & génération de suites \\
    \verb=%*%=\, \verb=%\%=\, \verb=%/%= & produit
    matriciel, modulo, division entière \\
    \verb=*=\, \verb=/= & multiplication, division \\
    \verb=+=\, \verb=-= & addition, soustraction \\
    \verb|<|\, \verb|<=|\, \verb|==|\, \verb|>=|\,
    \verb|>|\, \verb|!=| & plus petit, plus petit ou égal, égal,
    plus grand ou égal, plus grand, différent de \\
    \verb=!= & négation logique \\
    \verb=&=\, \verb=&&= & «et» logique \\
    \verb=|=\, \verb=||= & «ou» logique \\
    \verb|->|\, \verb|->>| & affectation \\
    \verb|<-|\, \verb|<<-| & affectation \\
    \bottomrule
  \end{tabular}
  \caption{Principaux opérateurs du langage R, en ordre décroissant
    de priorité}
  \label{tab:bases:operateurs}
\end{table}

\tipbox{Il est utile, voire essentiel de connaître le niveau de
  priorité des opérateurs dans les expressions R.}


\section{Commandes R}
\label{sec:bases:commandes}

L'utilisateur de R interagit avec l'interpréteur R en entrant des
commandes à la ligne de commande. Toute commande R est soit une
\emph{expression}\index{expression}, soit une
\emph{affectation}\index{affectation}.

\subsection{Expressions}
\label{sec:bases:commandes:expressions}

Une expression R est une combinaison de symboles (noms de variables)
et de procedures. Toute expression a une valeur. Le symbole d'une
donnée fondamentale représente cette donnée, comme on pourrait s'y
attendre.

Lorsqu'une expression est entrée à la ligne de commande de
l'interpréteur, elle est immédiatement évaluée et le résultat est
affiché sous l'invite de commande (le symbole \verb|>| suivi d'une
espace).
<<echo=TRUE>>=
42
3 + 2i
2 + 3
pi
cos(pi/4)
@

Lorsqu'une commande n'est pas syntaxiquement complète, l'invite de
commande devient \verb*|+ | pour nous inciter à compléter la
commande.
<<echo=TRUE>>=
2 *
3
@

Il est possible de combiner plusieurs expressions ensemble pour en
faire une expression composée. Celle-ci est évaluée de gauche à
droite, à moins que des parenthèses ne viennent changer l'ordre
d'évaluation, comme en mathématiques.
<<echo=TRUE>>=
(2 + ((2 + 4 * 6) * (3 + 5 + 7)))/2
@

\subsection{Affectations}
\label{sec:bases:commandes:affectations}

Dans une affectation, une expression est évaluée, mais le résultat est
stocké dans un \emph{objet} (ou \emph{variable}) dans l'espace de
travail et rien n'est affiché à l'écran. Tel que mentionné
précédemment, le symbole d'affectation est \Fonction{<-}, c'est-à-dire
les deux caractères \verb|<| et \verb|-| placés obligatoirement l'un à
la suite de l'autre.
<<echo=TRUE>>=
a <- 5
a
b <- a
b
@

Pour affecter le résultat d'un calcul dans un objet et simultanément
afficher ce résultat, il suffit de placer l'affectation entre
parenthèses pour ainsi créer une nouvelle expression\footnote{%
  En fait, cela devient un appel à l'opérateur \code{"("} qui ne fait
  que retourner son argument.}.
<<echo=TRUE>>=
(a <- 2 + 3)
@

Le symbole d'affectation inversé \fonction{->} existe aussi, mais il
est rarement utilisé.

\cautionbox{Évitez d'utiliser l'opérateur \,\fonction{=}\, pour
  affecter une valeur à une variable. Cette pratique est susceptible
  d'engendrer de la confusion avec les constructions \code{nom =
    valeur} dans les appels de fonction. Les règles de syntaxe de R
  commandent d'utiliser l'opérateur \code{<-} pour l'affectation,
  point.}

\subsection{Regroupements de commandes}
\label{sec:bases:commandes:regroupements}

Dans les fichiers de script ou à la ligne de commande, on sépare les
commandes R les unes des autres par un \index{;@\code{;}}point-virgule
ou par un retour à la ligne. On considère généralement comme du
mauvais style d'employer les deux, c'est-à-dire de placer des
points-virgules à la fin de chaque ligne de code, surtout dans les
fichiers de script. Le point-virgule peut être utile pour séparer deux
courtes expressions ou plus sur une même ligne. C'est le seul emploi
que nous faisons du point-virgule.
<<echo=TRUE>>=
a <- 5; a + 2
@

On peut regrouper plusieurs commandes en une seule expression en les
entourant d'accolades \Fonction{\{~\}}. Le résultat du regroupement
est la valeur de la \emph{dernière} commande. Par conséquent, si le
regroupement se termine par une affectation, aucune valeur n'est
retournée ni affichée à l'écran.
<<echo=TRUE>>=
{
    a <- 2 + 3
    b <- a
    b
}
@
<<echo=TRUE>>=
{
    a <- 2 + 3
    b <- a
}
@




\section{Objets R}
\label{sec:bases:objets}

Tout dans le langage R est un objet: les variables contenant des
données, les fonctions, les opérateurs, même le symbole représentant
le nom d'un objet est lui-même un objet. Les objets possèdent au
minimum un \emph{mode} et une \emph{longueur} et certains peuvent
être dotés d'un ou de plusieurs \emph{attributs}.

\subsection{Règles pour les noms d'objets}
\label{sec:bases:objets:noms}

Les caractères permis pour les noms d'objets sont les lettres
minuscules a--z et majuscules A--Z, les chiffres 0--9, le point «.» et
le caractère de soulignement «\_». Selon l'environnement linguistique
de l'ordinateur, il peut être permis d'utiliser des lettres accentuées
dans les noms d'objet, mais nous recommandons fortement d'éviter cette
pratique qui nuit à la portabilité du code. Le nom d'un objet ne peut
débuter par un chiffre. Si le nom débute par un point, alors le second
caractère ne peut être un chiffre.

\warningbox{R est sensible à la casse, ce qui signifie que \code{foo},
  \code{Foo} et \code{FOO} sont trois objets distincts.}

Certains noms sont utilisés par le système R, aussi vaut-il mieux
éviter de les utiliser comme nom de variable ou de fonction. En
particulier, évitez:
\begin{quote}
  \code{c}, \code{q}, \code{t}, \code{C}, \code{D},
  \code{I}, \code{diff}, \code{length}, \code{mean},
  \code{pi}, \code{range}, \code{var}.
\end{quote}
De plus, certains mots sont réservés et il est interdit de les
utiliser comme nom d'objet. Les mots réservés pour le système sont:
\begin{quote}
  \code{break}, \code{else}, \code{for}, \code{function}, \code{if},
  \code{in}, \code{next}, \code{repeat}, \code{return}, \code{while}, \\
  \code{TRUE}, \code{FALSE}, \\
  \code{Inf}, \code{NA}, \code{NaN}, \code{NULL}, \\
  \verb|NA_integer_|, \verb|NA_real_|, \verb|NA_complex_|,
  \verb|NA_character_|, \\
  \code{...}, \code{..1}, \code{..2}, etc.
\end{quote}
Oui, `\code{...}' (\emph{point-point-point}) est véritablement un nom
d'objet dans R! Son usage est expliqué à la
\autoref{sec:bases:fonctions:dots}.

Les variables \code{T}\index{T@\code{T}|see{\code{TRUE}}} et
\code{F}\index{F@\code{F}|see{\code{FALSE}}} prennent par défaut les
valeurs \objet{TRUE} et \objet{FALSE}, respectivement, mais peuvent
être réaffectées.
<<echo=TRUE>>=
T
F
@
\begin{Schunk}
\begin{Sinput}
> TRUE <- 3
\end{Sinput}
\begin{Soutput}
Error in TRUE <- 3 : membre gauche de l'assignation
(do_set) incorrect
\end{Soutput}
\end{Schunk}
<<echo=TRUE>>=
(T <- 3)
@
<<echo=FALSE>>=
rm(T)
@

\tipbox{Nous recommandons de toujours écrire les valeurs booléennes
  \code{TRUE} et \code{FALSE} au long pour éviter des bogues
  difficiles à détecter.}


\subsection{Modes et types de données}
\label{sec:bases:objets:mode}

Le mode\Index{mode} prescrit ce qu'un objet peut contenir. À ce titre,
un objet ne peut avoir qu'un seul mode. Le \autoref{tab:bases:modes}
contient la liste des principaux modes disponibles en R. À chacun de
ces modes correspond une fonction du même nom servant à créer un objet
de ce mode. Le mode d'un objet est obtenu avec la fonction
\Fonction{mode}.
<<echo=TRUE>>=
v <- c(1, 2, 5, 9)
mode(v)
@

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    Mode              & Contenu de l'objet \\
    \midrule
    \Mode{numeric}    & nombres réels \\
    \Mode{complex}    & nombres complexes \\
    \Mode{logical}    & valeurs booléennes \\
    \Mode{character}  & chaines de caractères \\
    \Mode{function}   & fonction \\
    \Mode{list}       & liste \\
    \Mode{expression} & expressions non évaluées \\
    \bottomrule
  \end{tabular}
  \caption{Modes disponibles et contenus correspondants}
  \label{tab:bases:modes}
\end{table}

Les objets de mode \code{"numeric"}, \code{"complex"},
\code{"logical"} et \code{"character"} sont des objets \emph{simples}
(\emph{atomic}) qui contiennent des données d'un seul type. En
revanche, les objets de mode \code{"list"} ou \code{"expression"} sont
des objets \emph{récursifs} qui peuvent contenir d'autres objets. Par
exemple, une liste peut contenir une ou plusieurs autres listes; nous
y reviendrons au \autoref{chap:donnees}.

\tipbox{La fonction \Fonction{typeof} permet d'obtenir une description
  plus précise de la représentation interne d'un objet (c'est-à-dire
  au niveau de la mise en {\oe}uvre en C). Le mode et le type d'un
  objet sont souvent identiques.}


\subsection{Longueur}
\label{sec:bases:objets:longueur}

La longueur\Index{longueur} d'un objet est égale au nombre d'éléments
qu'il contient. La longueur d'un objet est obtenue avec la fonction
\Fonction{length}.
<<echo=TRUE>>=
v <- c(1, 2, 5, 9)
length(v)
@

\tipbox{Il est permis --- et parfois utile --- de créer un objet de
  longueur nulle, c'est-à-dire un objet qui existe, mais qui est
  vide.}

Au sens R du terme, la longueur d'une chaine de caractères est
toujours $1$. Un objet de mode \code{character} doit contenir
plusieurs chaines de caractères pour que sa longueur soit supérieure à
$1$. Il faut utiliser la fonction \Fonction{nchar} pour obtenir le
nombre de caractères dans une chaine.
<<echo=TRUE>>=
v1 <- "actuariat"
length(v1)
nchar(v1)
@
<<echo=TRUE>>=
v2 <- c("a", "c", "t", "u", "a", "r", "i", "a", "t")
length(v2)
nchar(v2)
@

\subsection{Valeurs spéciales}
\label{sec:bases:objets:NA_et_al}

Les objets valeur manquante (\code{NA}), infini (\code{Inf},
\code{-Inf}), valeur indéterminée (\code{NaN}) et néant (\code{NULL})
permettent de représenter de manière intuitive des quantitées souvent
utilisées dans les applications statistiques et en analyse de données.
Pour pleinement tirer profit de ces objets, il faut connaitre leurs
caractéristiques spéciales.

L'objet \code{NA} sert à représenter une donnée manquante. Chose un
peu surprenante, c'est un objet de mode \mode{logical}. Cependant,
\code{NA} ne peut être considéré ni \code{TRUE}, ni \code{FALSE}.
<<echo=TRUE>>=
mode(NA)
length(NA)
NA == TRUE
NA == FALSE
@
Toute opération, y compris la comparaison, impliquant la valeur
\code{NA} a comme résultat \code{NA}. Par conséquent, la valeur
\code{NA} n'est égale à aucune autre, pas même elle-même! Pour tester
si une valeur est manquante, il faut avoir recours à la fonction
\Fonction{is.na}.
<<echo=TRUE>>=
x <- NA
x == NA
is.na(NA)
@

Les objets \code{Inf}, \code{-Inf} et \code{NaN} permettent de
représenter les valeurs mathématiques spéciales prévues dans la norme
IEEE~754 régissant la représentation interne des nombres dans un
ordinateur \citep{IEEE:754}. De manière intuitive, l'objet \objet{Inf}
représente $+\infty$, \objet{-Inf} représente $-\infty$ et \Objet{NaN}
(\emph{Not a Number}) représente une forme indéterminée du type
$\frac{0}{0}$ ou $\infty - \infty$. Les fonctions
\Fonction{is.infinite}, \Fonction{is.finite} et \Fonction{is.nan}
fournissent des manières robuste de tester ces valeurs.
<<echo=TRUE>>=
is.infinite(1/0)
is.finite(-1/0)
is.nan(0/0)
is.nan(Inf - Inf)
@

Enfin, l'objet spécial \objet{NULL} représente «rien», ou le vide. Son
mode est \Mode{NULL} et sa longueur est $0$. Il est toutefois
différent d'un objet vide: un objet de longueur $0$ est un contenant
vide, alors que \code{NULL} est «pas de contenant».
<<echo=TRUE>>=
mode(NULL)
length(NULL)
1 + NULL
@
Toute opération avec \code{NULL} retourne un objet de longueur
nulle (et du mode approprié), y compris la comparaison. Par
conséquent, la seule façon de tester si un objet est \code{NULL} est
avec la fonction \Fonction{is.null}.
<<echo=TRUE>>=
x <- NULL
x == NULL
is.null(NULL)
@


\subsection{Attributs}
\label{sec:bases:objets:attributs}

Les attributs\Index{attribut} d'un objet sont des éléments
d'information additionnels attachées à cet objet. Le
\autoref{tab:attributs} fournit la liste des attributs les plus
fréquemment utilisés. À chacun correspond une fonction du même nom
servant à extraire l'attribut d'un objet.

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    Attribut            & Utilisation \\
    \midrule
    \Attribut{class}    &
    affecte le comportement d'un objet \\
    \Attribut{dim}      &
    dimensions\index{dimension} des matrices et tableaux \\
    \Attribut{dimnames} &
    étiquettes\index{etiquette@étiquette} des dimensions des matrices
    et tableaux \\
    \Attribut{names}    &
    étiquettes des éléments d'un objet \\
    \bottomrule
  \end{tabular}
  \caption{Attributs les plus usuels d'un objet}
  \label{tab:attributs}
\end{table}

La fonction \Fonction{attributes} permet d'extraire ou de modifier la
liste des attributs d'un objet, alors que la fonction \Fonction{attr}
permet de travailler sur un seul attribut à la fois. Les programmeurs
peuvent ajouter à peu près n'importe quoi à la liste des attributs
d'un objet. Par exemple, nous pourrions vouloir attacher au résultat
d'un calcul la méthode de calcul utilisée.
<<echo=TRUE>>=
x <- 3
attr(x, "methode") <- "au pif"
attributes(x)
@

L'extraction d'un attribut qui n'existe pas retourne \objet{NULL},
alors qu'à l'inverse, affecter à un attribut la valeur \code{NULL}
efface cet attribut.
<<echo=TRUE>>=
attributes(x)
dim(x)
attr(x, "methode") <- NULL
attributes(x)
@


\section{Vecteurs}
\label{sec:bases:vecteurs}

En R, à toutes fins pratiques, \emph{tout} est un
vecteur\index{vecteur}. C'est aussi l'unité de base dans les calculs.
Nous nous restreignons pour le moment aux vecteurs simples (atomiques)
dans lesquels tous les éléments sont du même mode.

\subsection{Création de vecteurs}
\label{sec:bases:vecteurs:creation}

La fonction de concaténation \Fonction{c} constitue la fonction de
base pour créer un vecteur.
<<echo=TRUE>>=
(x <- c(2, 5.1, 42))
@

Les fonctions \Fonction{numeric}, \Fonction{logical} et
\Fonction{character} permettent également de créer des vecteurs du
mode correspondant. Les fonctions prennent en argument la longueur du
vecteur à créer. Celui-ci contiendra des valeurs initiales
prédéterminées.
<<echo=TRUE>>=
numeric(5)
logical(7)
character(10)
@

Il est possible --- et souvent souhaitable --- de nommer les éléments
d'un vecteur; on dit qu'on leur attribue une \emph{étiquette}. Ces
étiquettes font alors partie des attributs du vecteur. Il y a deux
grandes façons de procéder: en spécificant les noms dès la création du
vecteur, ou à posteriori en ajoutant l'attribut \attribut{names} au
vecteur.
<<echo=TRUE>>=
(v <- c(a = 1, b = 2, c = 5))
names(v)
@
<<echo=TRUE>>=
v <- c(1, 2, 5)
names(v) <- c("a", "b", "c")
v
@

\subsection{Indiçage}
\label{sec:bases:vecteurs:indicage}

L'indiçage des vecteurs est une procédure beaucoup utilisée dans le
langage R, aussi est-il important d'en maitriser toutes les
subtilités. L'opération sert principalement à deux choses: extraire
des éléments d'un objet avec la construction
\verb|x[i]|\indexfonction{[}, ou remplacer des éléments avec la
construction \verb|x[i] <- y|\Indexfonction{[<-}.

Dans un cas comme dans l'autre, il faut d'abord indicer le vecteur. Il
existe cinq façons de le faire dans le langage R, toujours à
l'intérieur de crochets \code{[~]}.
\begin{enumerate}
\item Avec un vecteur d'entiers positifs. Les éléments se trouvant aux
  positions correspondant aux entiers sont extraits du vecteur, dans
  l'ordre. C'est la technique la plus courante.
<<echo=TRUE>>=
x <- c(A = 2, B = 4, C = -1, D = -5, E = 8)
x[c(1, 3)]
@
\item Avec un vecteur d'entiers négatifs. Les éléments se trouvant aux
  positions correspondant aux entiers négatifs sont \emph{éliminés} du
  vecteur.
<<echo=TRUE>>=
x[c(-2, -3)]
@
\item Avec un vecteur booléen. Le vecteur d'indiçage doit alors être
  de la même longueur que le vecteur indicé. Les éléments
  correspondant à une valeur \code{TRUE} sont extraits du vecteur,
  alors que ceux correspondant à \code{FALSE} sont éliminés.
<<echo=TRUE>>=
x > 0
x[x > 0]
@
\item Avec un vecteur de chaines de caractères. Les éléments
  dont l'étiquette correspond à l'une des chaines sont extraits du
  vecteur. Ce mode d'indiçage par le nom permet d'extraire des élément
  d'un vecteur indépendemment de leur position dans celui-ci.
<<echo=TRUE>>=
x[c("B", "D")]
@
\item L'indice est laissé vide. Tous les éléments du vecteur sont
  alors sélectionnés.
<<echo=TRUE>>=
x[]
@
  Cette méthode est essentiellement utilisée avec les matrices et
  tableaux pour sélectionner tous les éléments d'une dimension; nous y
  reviendrons au \autoref{chap:donnees}. Laisser l'indice vide est
  différent d'indicer avec un vecteur vide. Cette dernière opération
  retourne un vecteur vide.
\end{enumerate}

\tipbox{Il n'est pas inutile de savoir que les opérations d'extraction
  et de remplacement sont en fait traduites par l'interpréteur R en
  des appels à des fonctions nommées \fonction{[} et \Fonction{[<-},
  dans l'ordre.}

\subsection{Arithmétique vectorielle}
\label{sec:bases:vecteurs:arithmetique}

L'arithmétique vectorielle de R constitue l'une des grandes forces du
langage. Elle permet de réaliser une grande variété de calculs sans
avoir recours à des procédures itératives (boucles).

Les procédures fondamentales de la \autoref{sec:bases:fondamentales}
peuvent toutes opérer sur les vecteurs en effectuant les opérations
\emph{élément par élément}. C'est la première règle de base des
opérations arithmétiques dans R.
<<echo=TRUE>>=
c(1, 2, 3) + c(4, 5, 6)
1:3 * 4:6
@

La seconde règle de base se rapporte aux opérations entre des vecteurs
de longueurs différentes. Dans de tels cas, les vecteurs les plus
courts sont \emph{recyclés} autant de fois que nécessaire pour
correspondre au plus long vecteur. Cette règle est particulièrement
apparente avec les vecteurs de longueur $1$.
<<echo=TRUE>>=
1:10 + 2
@

Si la longueur du plus long vecteur est un multiple de celle du ou des
autres vecteurs, ces derniers sont recyclés un nombre entier de fois.
<<echo=TRUE>>=
1:10 + 1:5 + c(2, 4)
@

Autrement, le plus court vecteur est recyclé un nombre fractionnaire
de fois, mais comme ce résultat est rarement celui souhaité et qu'il
provient généralement d'une erreur de programmation, un avertissement
est affiché.
\begin{Schunk}
\begin{Sinput}
> 1:10 + c(2, 4, 6)
\end{Sinput}
\begin{Soutput}
 [1]  3  6  9  6  9 12  9 12 15 12
Message d'avis :
In 1:10 + c(2, 4, 6) :
la taille d'un objet plus long n'est pas un multiple de la
taille d'un objet plus court
\end{Soutput}
\end{Schunk}


\section{Fonctions}
\label{sec:bases:fonctions}

Nous avons mentionné au début de la \autoref{sec:bases:fondamentales}
qu'un langage de programmation devrait fournir un mécanisme
d'abstraction pour utiliser les éléments composés. La possibilité que
nous offre R de définir des objets contenant des valeurs constitue une
première technique. La définition de \emph{fonctions} (le nom que nous
donnerons dorénavant au concept de procédure) est une technique
d'abstration encore plus puissante, puisqu'elle permet de faire
référence par un seul nom à toute une suite d'opérations.

Nous adoptons en bonne partie dans R le paradigme de la programmation
fonctionnelle. Tel qu'expliqué sommairement à la
\autoref{sec:informatique:paradigmes}, dans ce paradigme un programme
est constitué d'une suite d'appels de fonctions.

L'approche de programmation fonctionnelle dans R fait aussi en sorte
qu'une fonction est traitée comme n'importe quel autre objet. Entre
autres choses, cela signifie que:
\begin{itemize}
\item le contenu d'une fonction (son code source) est toujours
  accessible;
\item une fonction peut accepter en argument une autre fonction;
\item une fonction peut retourner une fonction comme résultat;
\item l'utilisateur peut définir de nouvelles fonctions.
\end{itemize}

\subsection{Appels de fonctions}
\label{sec:bases:fonctions:appel}

Avant de penser définir des fonctions, il convient d'étudier les
règles d'appel d'une fonction dans R et la façon de spécifier les
arguments.

\begin{itemize}
\item L'interpréteur R reconnait un appel de fonction au fait que le
  nom de l'objet est suivi de parenthèses \code{(~)}.
\item Une fonction peut n'avoir aucun argument ou plusieurs. Il n'y a
  pas de limite pratique au nombre d'arguments que peut avoir une
  fonction.
\item Les arguments d'une fonction peuvent être spécifiés selon
  l'ordre établi dans la définition de la fonction. Cependant, il est
  beaucoup plus prudent et \emph{fortement recommandé} de spécifier
  les arguments par leur nom, avec une construction de la forme
  \code{symbole = expression}, surtout après les deux ou trois
  premiers arguments.
\item L'ordre des arguments est important; il est donc nécessaire de
  les nommer s'ils ne sont pas appelés dans l'ordre.
\item Certains arguments ont une valeur par défaut qui sera utilisée
  si l'argument n'est pas spécifié dans l'appel de la fonction.
\end{itemize}

Par exemple, la définition de la fonction \texttt{matrix} est la
suivante:
\begin{verbatim}
   matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE,
          dimnames = NULL)
\end{verbatim}
\begin{itemize}
  \sloppy
\item La fonction compte cinq arguments: \argument{data},
  \argument{nrow}, \argument{ncol}, \argument{byrow} et
  \argument{dimnames}.
\item Ici, chaque argument a une valeur par défaut (ce n'est pas
  toujours le cas). Ainsi, un appel à \code{matrix} sans argument
  résulte en une matrice $1 \times 1$ remplie par colonne (sans
  importance, ici) de l'objet \code{NA} et dont les dimensions sont
  dépourvues d'étiquettes:
<<echo=TRUE>>=
matrix()
@
\item Appel plus élaboré utilisant tous les arguments. Le premier
  argument est rarement nommé:
<<echo=TRUE>>=
matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE,
       dimnames = list(c("Gauche", "Droit"),
       c("Rouge", "Vert", "Bleu")))
@
\end{itemize}


\subsection{Définition d'une fonction}
\label{sec:bases:fonctions:definition}

La syntaxe pour définir une fonction est la suivante:
\Indexfonction{function}
\begin{Schunk}
\begin{Verbatim}[commandchars=\\\{\}]
\meta{nom} <- function(\meta{arguments}) \meta{corps}
\end{Verbatim}
\end{Schunk}

\begin{itemize}
\item \meta{arguments} est la liste des arguments formels de la
  fonction, séparés par des virgules. Les arguments formels d'une
  fonction peuvent être des symboles, des instructions de la forme
  \code{symbole = expression}, ou encore l'argument formel spécial
  `\code{...}'.
\item \meta{corps} est une expression ou un groupe d'expressions
  réunies par des accolades, tel qu'expliqué à la
  \autoref{sec:bases:commandes:regroupements}.
\item \meta{nom} est le nom de la fonction (les règles pour les noms
  de fonctions étant les mêmes que celles présentées à la
  \autoref{sec:bases:objets:noms} pour tout autre objet).
\end{itemize}

<<echo=TRUE>>=
square <- function(x) x * x
square(5)
@

Nous souhaitons généralement attribuer un nom à une fonction, mais
c'est tout à fait optionnel. En effet, l'appel à \fonction{function}
retourne déjà une fonction et si aucun nom ne lui est attribué, on
obtient ce qui est appelé une \emph{fonction anonyme}.

\section{Retourner des résultats}
\index{fonction!resultats@résultat}
\label{fonctions:resultats}

La plupart des fonctions sont écrites dans le but de retourner un
résultat. Or, les règles d'interprétation d'un groupe d'expressions
présentées à la \autoref{bases:commandes} s'appliquent ici au
corps de la fonction.
\begin{itemize}
\item Une fonction retourne tout simplement le résultat de la
  \emph{dernière expression} du corps de la fonction.
\item On évitera donc que la dernière expression soit une affectation,
  car la fonction ne retournera alors rien et on ne pourra utiliser
  une construction de la forme \code{x <- f()} pour affecter le
  résultat de la fonction à une variable.
\item Si on doit retourner un résultat sans être à la dernière ligne
  de la fonction (à l'intérieur d'un bloc conditionnel, par exemple),
  on utilise la fonction \Fonction{return}. \emph{L'utilisation de
    \code{\emph{return}} à la toute fin d'une fonction est tout à fait
    inutile et considérée comme du mauvais style en R.}
\item Lorsqu'une fonction doit retourner plusieurs résultats, il est
  en général préférable d'avoir recours à une liste nommée.
\end{itemize}



\section{Variables locales et globales}
\label{fonctions:variables}

Comme la majorité des langages de programmation, R comporte des
concepts de variable locale et de variable globale.

\begin{itemize}
\item Toute variable définie dans une fonction est
  locale\index{variable!locale} à cette fonction, c'est-à-dire
  qu'elle:
  \begin{itemize}
  \item n'apparaît pas dans l'espace de travail;
  \item n'écrase pas une variable du même nom dans l'espace de
    travail.
  \end{itemize}
\item Il est possible de définir une variable\index{variable!globale}
  dans l'espace de travail depuis une fonction avec l'opérateur
  d'affectation \verb|<<-|\index{<<-@\verb=<<-=}. Il est très
  rare --- et généralement non recommandé --- de devoir recourir à de
  telles variables globales.
\item On peut définir une fonction à l'intérieur d'une autre fonction.
  Cette fonction sera locale à la fonction dans laquelle elle est
  définie.
\end{itemize}

Le lecteur intéressé à en savoir plus pourra consulter les sections de
la documentation de R portant sur la portée lexicale (\emph{lexical
  scoping}). C'est un sujet important et intéressant, mais
malheureusement trop avancé pour ce document d'introduction à la
programmation en R.

\subsection{Fonctions avec un nombre variable d'arguments}
\label{sec:bases:fonctions:dot-dot-dot}



\subsection{Fonctions anonymes}
\index{fonction!anonyme}
\label{fonctions:anonymes}

Il est parfois utile de définir une fonction sans lui attribuer un nom
--- d'où la notion de \emph{fonction anonyme}. Il s'agira en général
de fonctions courtes utilisées dans une autre fonction. Par exemple,
pour calculer la valeur de $x y^2$ pour toutes les combinaisons de $x$
et $y$ stockées dans des vecteurs du même nom, on pourrait utiliser la
fonction \fonction{outer} ainsi:
<<echo=TRUE>>=
x <- 1:3; y <- 4:6
f <- function(x, y) x * y^2
outer(x, y, f)
@

Cependant, si la fonction \code{f} ne sert à rien ultérieurement, on
peut se contenter de passer l'objet fonction à \fonction{outer} sans
jamais lui attribuer un nom:
<<echo=TRUE>>=
outer(x, y, function(x, y) x * y^2)
@
On a alors utilisé dans \code{outer} une fonction anonyme.



\section{Exemples}
\label{bases:exemples}

\lstinputlisting[firstline=3]{bases.R}


\vspace{\fill}

\section{Exercices}
\label{bases:exercices}

\Opensolutionfile{solutions}[solutions-bases]

\begin{Filesave}{solutions}
\section*{Chapitre \ref*{bases}}
\addcontentsline{toc}{section}{Chapitre \protect\ref*{bases}}

\end{Filesave}

\begin{exercice}
  \begin{enumerate}
  \item Écrire une expression R pour créer la liste suivante:
<<echo=FALSE>>=
x <- list(1:5, data=matrix(1:6, 2, 3), numeric(3), test=logical(4))
@
<<echo=TRUE>>=
x
@ %
  \item \index{etiquette@étiquette} Extraire les étiquettes de la
    liste.
  \item \index{mode} \index{longueur} Trouver le mode et la longueur
    du quatrième élément de la liste.
  \item \index{dimension} Extraire les dimensions du second élément de
    la liste.
  \item \index{indiçage!liste} Extraire les deuxième et troisième
    éléments du second élément de la liste.
  \item Remplacer le troisième élément de la liste par le vecteur
    \verb|3:8|.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
    \item Il y a plusieurs façons de créer les troisième et quatrième
      éléments de la liste. Le plus simple consiste à utiliser
      \code{numeric()} et \code{logical()}:
<<echo=TRUE,eval=FALSE>>=
x <- list(1:5, data = matrix(1:6, 2, 3), numeric(3),
          test = logical(4))
@
    \item
<<echo=TRUE,eval=FALSE>>=
names(x)
@
    \item
<<echo=TRUE,eval=FALSE>>=
mode(x$test)
length(x$test)
@
    \item
<<echo=TRUE,eval=FALSE>>=
dim(x$data)
@
    \item
<<echo=TRUE,eval=FALSE>>=
x[[2]][c(2, 3)]
@
    \item
<<echo=TRUE,eval=FALSE>>=
x[[3]] <- 3:8
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\begin{exercice}
  \index{indiçage!vecteur}
  Soit \code{x} un vecteur contenant les valeurs d'un échantillon:
  \begin{center}
<<echo=FALSE>>=
x <- sample(1:20, 20, replace = TRUE)
@
<<echo=TRUE>>=
x
@
  \end{center}
  Écrire une expression R permettant d'extraire les éléments suivants.
  \begin{enumerate}
  \item Le deuxième élément de l'échantillon.
  \item Les cinq premiers éléments de l'échantillon.
  \item Les éléments strictement supérieurs à $14$.
  \item Tous les éléments sauf les éléments en positions $6$, $10$ et $12$.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=TRUE,eval=FALSE>>=
x[2]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[1:5]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[x > 14]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[-c(6, 10, 12)]
@
    \end{enumerate}
  \end{sol}
\end{exercice}
%\vspace{\fill}

\begin{exercice}
  \index{indiçage!matrice}
  Soit \code{x} une matrice $10 \times 7$ obtenue aléatoirement avec
<<echo=TRUE,eval=FALSE>>=
x <- matrix(sample(1:100, 70), 7, 10)
@
  Écrire des expressions R permettant d'obtenir les éléments de la
  matrice demandés ci-dessous.
  \begin{enumerate}
  \item L'élément $(4, 3)$.
  \item Le contenu de la sixième ligne.
  \item Les première et quatrième colonnes (simultanément).
  \item Les lignes dont le premier élément est supérieur à $50$.
  \end{enumerate}
  \begin{sol}
    \begin{enumerate}
\item
<<echo=TRUE,eval=FALSE>>=
x[4, 3]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[6, ]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[, c(1, 4)]
@
\item
<<echo=TRUE,eval=FALSE>>=
x[x[, 1] > 50, ]
@
    \end{enumerate}
  \end{sol}
\end{exercice}

\Closesolutionfile{solutions}

%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
