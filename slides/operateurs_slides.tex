\section{Opérateurs et fonctions}

\begin{frame}
  \frametitle{Une liste non exhaustive}

  \begin{itemize}
  \item Principaux opérateurs arithmétiques, fonctions mathématiques
    et structures de contrôles offertes par le S.
  \item Liste loin d'être exhaustive.
  \item Consulter aussi la section \texttt{See Also} des rubriques
    d'aide.
  \end{itemize}
\end{frame}


\subsection{Opérations arithmétiques}

\begin{frame}[fragile=singleslide]
  \frametitle{L'unité de base est le vecteur}
  
  \begin{itemize}
  \item Les opérations sur les vecteurs sont effectuées \alert{élément
      par élément}:
\begin{Schunk}
\begin{Sinput}
> c(1, 2, 3) + c(4, 5, 6)
\end{Sinput}
\begin{Soutput}
[1] 5 7 9
\end{Soutput}
\begin{Sinput}
> 1:3 * 4:6
\end{Sinput}
\begin{Soutput}
[1]  4 10 18
\end{Soutput}
\end{Schunk}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]
  \frametitle{Recyclage des vecteurs}
  
  \begin{itemize}
  \item Si les vecteurs impliqués dans une expression arithmétique ne
    sont pas de la même longueur, les plus courts sont
    \alert{recyclés}.
  \item Particulièrement apparent avec les vecteurs de longueur 1:
\begin{Schunk}
\begin{Sinput}
> 1:10 + 2
\end{Sinput}
\begin{Soutput}
 [1]  3  4  5  6  7  8  9 10 11 12
\end{Soutput}
\begin{Sinput}
> 1:10 + rep(2, 10)
\end{Sinput}
\begin{Soutput}
 [1]  3  4  5  6  7  8  9 10 11 12
\end{Soutput}
\end{Schunk}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]
  \frametitle{Longueur du plus long vecteur multiple de celle des
    autres vecteurs}

  \begin{itemize}
  \item Les vecteurs les plus courts sont recyclés un nombre entier de
    fois:
\begin{Schunk}
\begin{Sinput}
> 1:10 + 1:5 + c(2, 4)
\end{Sinput}
\begin{Soutput}
[1]  4  8  8 12 12 11 11 15 15 19
\end{Soutput}
\begin{Sinput}
> 1:10 + rep(1:5, 2) + rep(c(2, 4), 5)
\end{Sinput}
\begin{Soutput}
[1]  4  8  8 12 12 11 11 15 15 19
\end{Soutput}
\end{Schunk}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]
  \frametitle{Sinon...}

  \begin{itemize}
  \item Recyclage un nombre fractionnaire de fois et un avertissement
    est affiché:
\begin{Schunk}
\begin{Sinput}
> 1:10 + c(2, 4, 6)
\end{Sinput}
\begin{Soutput}
[1]  3  6  9  6  9 12  9 12 15 12
Message d'avis :
la longueur de l'objet le plus long n'est 
pas un multiple de la longueur de l'objet 
le plus court in: 1:10 + c(2, 4, 6)
\end{Soutput}
\end{Schunk}
  \end{itemize}
\end{frame}


\subsection{Opérateurs}

\begin{frame}[fragile=singleslide]
  \frametitle{Opérateurs mathématiques et logiques les plus
    fréquemment employés}

  Ordre décroissant de priorité des opérations.

  \begin{center}
    \renewcommand{\arraystretch}{1.1}
    \begin{tabular}{lp{30ex}}
      \toprule
      \Fonction{\^} ou \Fonction{**} & puissance \\
      \Fonction{-} & changement de signe \\
      \Fonction{*} \Fonction{/} & multiplication, division \\
      \Fonction{+} \Fonction{-} & addition, soustraction \\
      \Fonction{\%*\%} \Fonction{\%\%} \Fonction{\%/\%} & produit
      matriciel, modulo, division entière \\
      \Fonction{<} \Fonction{<=} \Fonction{==} \Fonction{>=}
      \Fonction{>} \verb|!=| & plus petit, plus petit ou égal, égal,
      plus grand ou égal, plus grand, différent de \\
      \verb|!| & négation logique \\
      \Fonction{\&} \Fonction{|} & «et» logique, «ou» logique \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{frame}

\subsection{Appels de fonctions}

\begin{frame}
  \frametitle{Comment spécifier les arguments d'une fonction}

  \begin{itemize}[<+->]
  \item Pas de limite pratique au nombre d'arguments.
  \item Arguments peuvent être spécifiés dans l'ordre établi dans la
    définition de la fonction.
  \item Plus prudent et \alert{fortement recommandé} de spécifier les
    arguments par leur nom, surtout après les deux ou trois premiers
    arguments.
  \item Nécessaire de nommer les arguments s'ils ne sont pas appelés
    dans l'ordre.
  \item Certains arguments ont une valeur par défaut qui sera utilisée
    si l'argument n'est pas spécifié.
  \end{itemize}
\end{frame}

\subsection{Exemple}

\begin{frame}[fragile]
  \frametitle{Exemple}

  Définition de la fonction \texttt{matrix}:

\begin{semiverbatim}
    matrix({\color{red}data=NA}, {\color{blue}nrow=1}, {\color{magenta}ncol=1},
           {\color{orange}byrow=FALSE}, {\color{brown}dimnames=NULL})
\end{semiverbatim}
  \pause

  \begin{itemize}[<+->]
  \item Chaque argument a une valeur par défaut (ce n'est pas toujours
    le cas).
  \item Ainsi, un appel à \code{matrix} sans argument résulte en
\begin{Schunk}
\begin{Sinput}
> matrix()
\end{Sinput}
\begin{Soutput}
     [,1]
[1,]   NA
\end{Soutput}
\end{Schunk}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]

  \begin{itemize}
  \item Appel plus élaboré utilisant tous les arguments. Le premier
    argument est rarement nommé.
\begin{Schunk}
\begin{Sinput}
> matrix(1:6, nrow = 2, ncol = 3, 
+  byrow = TRUE, 
+  dimnames = list(c("Gauche", "Droit"), 
+    c("Rouge", "Vert", "Bleu")))
\end{Sinput}
\begin{Soutput}
       Rouge Vert Bleu
Gauche     1    2    3
Droit      4    5    6
\end{Soutput}
\end{Schunk}
  \end{itemize}
\end{frame}


\subsection{Quelques fonctions utiles}

\begin{frame}
  \frametitle{Système de classement des fonctions}

  \begin{itemize}[<+->]
  \item Diffère entre S-Plus et \textsf{R}.
  \item Dans S-Plus, les fonctions sont classées dans des
    \alert{sections} d'une bibliothèque (\emph{library}).
  \item Dans \textsf{R}, un ensemble de fonctions est appelé un
    \alert{package}.
  \item Par défaut, \textsf{R} charge en mémoire quelques packages de
    la bibliothèque seulement.
  \item Cela économise l'espace mémoire et accélère le démarrage.
  \item On charge de nouveaux packages en mémoire avec la fonction
    \fonction{library}.
  \end{itemize}
\end{frame}

\subsection{Manipulation de vecteurs}

\begin{frame}
  \frametitle{Manipulation de vecteurs}

  \begin{ttscript}{unique}
  \item[\Fonction{seq}] génération de suites de nombres\index{suite de
      nombres}
  \item[\Fonction{rep}] répétition\index{repetition@répétition de
      valeurs} de valeurs ou de vecteurs
  \item[\Fonction{sort}] tri\index{tri} en ordre croissant ou
    décroissant
  \item[\Fonction{order}] positions dans un vecteur des valeurs en
    ordre croissant ou décroissant
  \item[\Fonction{rank}] rang\index{rang} des éléments d'un vecteur en
    ordre croissant ou décroissant
  \item[\Fonction{rev}] renverser\index{renverser un vecteur} un
    vecteur
  \item[\Fonction{head}] extraction\index{extraction!premières
      valeurs} des $n$ premières valeurs ou suppression des $n$
    dernières (\textsf{R} seulement)
    \index{extraction|seealso{indiçage}}
  \item[\Fonction{tail}] extraction\index{extraction!dernières
      valeurs} des $n$ dernières valeurs ou suppression des $n$
    premières (\textsf{R} seulement)
  \item[\Fonction{unique}] extraction des éléments
    différents\index{extraction!elements différents@éléments
      différents} d'un vecteur
  \end{ttscript}
\end{frame}

\subsection{Recherche d'éléments dans un vecteur}

\begin{frame}
  \frametitle{Recherche d'éléments dans un vecteur}
  \begin{ttscript}{which.max}
  \item[\Fonction{which}] positions des valeurs \texttt{TRUE} dans un
    vecteur booléen
  \item[\Fonction{which.min}] position du
    minimum\index{minimum!position dans un vecteur} dans un vecteur
  \item[\Fonction{which.max}] position du
    maximum\index{maximum!position dans un vecteur} dans un vecteur
  \item[\Fonction{match}] position de la première occurrence d'un
    élément dans un vecteur
  \item[\Fonction{\%in\%}] appartenance d'une ou plusieurs valeurs à
    un vecteur
  \end{ttscript}
\end{frame}

\subsection{Arrondi}

\begin{frame}
  \frametitle{Arrondi}
  \begin{ttscript}{ceiling}
  \item[\Fonction{round}] arrondi\index{arrondi} à un nombre défini de
    décimales
  \item[\Fonction{floor}] plus grand entier inférieur ou égal à
    l'argument
  \item[\Fonction{ceiling}] plus petit entier supérieur ou égal à
    l'argument
  \item[\Fonction{trunc}] troncature vers zéro de l'argument;
    différent de \texttt{floor} pour les nombres négatifs
  \end{ttscript}
\end{frame}

\subsection{Sommaires et statistiques descriptives}

\begin{frame}
  \frametitle{Sommaires et statistiques descriptives}
  \begin{ttscript}{sum, prod}
  \item[\Fonction{sum}, \Fonction{prod}] somme\index{somme} et
    produit\index{produit} des éléments d'un vecteur
  \item[\Fonction{diff}] différences\index{différences} entre les
    éléments d'un vecteur
  \item[\Fonction{mean}] moyenne
    arithmétique\index{moyenne!arithmétique} et moyenne
    tronquée\index{moyenne!tronquée}
  \item[\Fonction{var}, \Fonction{sd}] variance\index{variance} et
    écart type\index{ecart type@écart type} (versions sans biais)
  \item[\Fonction{min}, \Fonction{max}] minimum\index{minimum!d'un
      vecteur} et maximum\index{maximum!d'un vecteur} d'un vecteur
  \item[\Fonction{range}] vecteur contenant le minimum et le maximum
    d'un vecteur
  \item[\Fonction{median}] médiane\index{mediane@médiane} empirique
  \item[\Fonction{quantile}] quantiles\index{quantile} empiriques
  \item[\Fonction{summary}] statistiques descriptives d'un échantillon
  \end{ttscript}
\end{frame}

\subsection{Sommaires cumulatifs et comparaisons élément par élément}

\begin{frame}
  \frametitle{Sommaires cumulatifs et comparaisons élément par
    élément}
  \begin{ttscript}{cumsum, cumprod}
  \item[\Fonction{cumsum}, \Fonction{cumprod}]
    somme\index{somme!cumulative} et produit\index{produit!cumulatif}
    cumulatif d'un vecteur
  \item[\Fonction{cummin}, \Fonction{cummax}]
    minimum\index{minimum!cumulatif} et
    maximum\index{maximum!cumulatif} cumulatif
  \item[\Fonction{pmin}, \Fonction{pmax}]
    minimum\index{minimum!parallèle} et
    maximum\index{maximum!parallèle} en parallèle, c'est-à-dire
    élément par élément entre deux vecteurs ou plus
  \end{ttscript}
\end{frame}

\subsection{Opérations sur les matrices}

\begin{frame}
  \frametitle{Opérations sur les matrices}
  \begin{ttscript}{nrow, ncol}
  \item[\Fonction{t}] transposée\index{matrice!transposée}
  \item[\Fonction{solve}] avec un seul argument (une matrice carrée):
    inverse\index{matrice!inverse} d'une matrice; avec deux arguments
    (une matrice carrée et un vecteur): solution du système d'équation
    $\mat{A} \mat{x} = \mat{b}$
  \item[\Fonction{diag}] avec une matrice en argument: diagonale de la
    matrice; avec un vecteur en argument: matrice
    diagonale\index{matrice!diagonale} formée avec le vecteur; avec un
    scalaire $p$ en argument: matrice identité\index{matrice!identité}
    $p \times p$
  \item[\Fonction{nrow}, \Fonction{ncol}] nombre de lignes et de
    colonnes d'une matrice
  \end{ttscript}
\end{frame}

\begin{frame}
  \frametitle{Opérations sur les matrices (suite)}
  \begin{ttscript}{rowMeans, colMeans}
  \item[\Fonction{rowSums}, \Fonction{colSums}]
    sommes\index{matrice!sommes par ligne} par ligne et par
    colonne\index{matrice!somme par colonne}, respectivement, des
    éléments d'une matrice; voir aussi la fonction \fonction{apply}
  \item[\Fonction{rowMeans}, \Fonction{colMeans}]
    moyennes\index{matrice!moyennes par ligne} par ligne et par
    colonne\index{matrice!moyennes par colonne}, respectivement, des
    éléments d'une matrice; voir aussi la fonction \fonction{apply}
  \item[\Fonction{rowVars}, \Fonction{colVars}]
    variance\index{matrice!variance par ligne} par ligne et par
    colonne\index{matrice!variance par colonne} des éléments d'une
    matrice (S-Plus seulement)
  \end{ttscript}
\end{frame}

\subsection{Produit extérieur}

\begin{frame}
  \frametitle{Produit extérieur}
  
  La fonction \Fonction{outer}, dont la syntaxe est
  \begin{center}
    \code{outer(X, Y, FUN)},
  \end{center}
  applique la fonction \code{FUN} (\fonction{prod} par défaut) entre
  chacun des éléments de \code{X} et chacun des éléments de \code{Y}.

  \begin{itemize}
  \item La dimension du résultat est par conséquent \code{c(dim(X),
      dim(Y))}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}[<+->]
  \item Par exemple: le produit extérieur entre deux vecteurs est une
    matrice contenant tous les produits entre les éléments des deux
    vecteurs:
\begin{Schunk}
\begin{Sinput}
> outer(c(1, 2, 5), c(2, 3, 6))
\end{Sinput}
\begin{Soutput}
     [,1] [,2] [,3]
[1,]    2    3    6
[2,]    4    6   12
[3,]   10   15   30
\end{Soutput}
\end{Schunk}
  \item L'opérateur \Fonction{\%o\%} est un raccourci de \code{outer(X,
      Y, prod)}.
  \end{itemize}
\end{frame}


\subsection{Structures de contrôle}

\begin{frame}
  \frametitle{Exécution conditionnelle}
  
  \begin{block}{\code{if (\emph{condition}) \emph{branche.vrai} else
      \emph{branche.faux}}}
    Si \code{\emph{condition}} est vraie, \code{\emph{branche.vrai}}
    est exécutée, et \code{\emph{branche.faux}} sinon. 
    \medskip

    Si l'une ou l'autre de \code{\emph{branche.vrai}} ou
    \code{\emph{branche.faux}} comporte plus d'une expression, les
    grouper dans des accolades $\{~\}$.
  \end{block}

  \begin{block}<2>{\code{ifelse(\emph{condition}, \emph{expression.vrai},
      \emph{expression.faux})}}
    Fonction vectorisée qui remplace chaque élément \code{TRUE} du
    vecteur \code{\emph{condition}} par l'élément correspondant de
    \code{\emph{expression.vrai}} et chaque élément \code{FALSE} par
    l'élément correspondant de \code{\emph{expression.faux}}.
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Boucles}

  \begin{itemize}[<+->]
  \item Les boucles sont et \alert{doivent} être utilisées avec
    parcimonie en S car elles sont généralement inefficaces
    (particulièrement avec S-Plus).
  \item Dans la majeure partie des cas, il est possible de vectoriser
    les calcul pour éviter les boucles explicites.
  \item Sinon, s'en remettre aux fonctions \fonction{apply},
    \fonction{lapply} et \fonction{sapply} pour faire les boucles de
    manière plus efficace.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Boucles de longueur déterminée}

  \begin{block}{\code{for (\emph{variable} in \emph{suite}) \emph{expression}}}
    Exécuter \code{\emph{expression}} successivement pour chaque
    valeur de \code{\emph{variable}} contenue dans
    \code{\emph{suite}}.
    \medskip

    Encore ici, on groupera les expressions dans des accolades
    $\{~\}$.
    \medskip

    À noter que \code{\emph{suite}} n'a pas à être composée de nombres
    consécutifs, ni même par ailleurs de nombres.
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Boucles de longueur indéterminée}

  \begin{block}{\code{while (\emph{condition}) \emph{expression}}}
    Exécuter \code{\emph{expression}} tant que \code{\emph{condition}}
    est vraie.
    \medskip

    Si \code{\emph{condition}} est fausse lors de l'entrée dans la
    boucle, celle-ci n'est pas exécutée.
    \medskip

    Une boucle \code{while} n'est par conséquent pas nécessairement
    toujours exécutée.
  \end{block}

  \begin{block}{\code{repeat \emph{expression}}}
    Répéter \code{\emph{expression}}. Cette dernière devra comporter un
    test d'arrêt qui utilisera la commande \code{break}.
    \medskip
    
    Une boucle \code{repeat} est toujours exécutée au moins une fois.
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Modification du déroulement d'une boucle}

  \begin{block}{\code{break}}
    Sortie immédiate d'une boucle \code{for}, \code{while} ou
    \code{repeat}.
  \end{block}
  \begin{block}{\code{next}}
    Passage immédiat à la prochaine itération d'une boucle \code{for},
    \code{while} ou \code{repeat}.
  \end{block}
\end{frame}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "introduction_programmation_S_slides"
%%% End: 
