%%% Copyright (C) 2017 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet «Programmer avec R»
%%% http://github.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition selon le contrat
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% http://creativecommons.org/licenses/by-sa/4.0/

\chapter{Débogage}
\label{chap:debogage}

<<echo=FALSE>>=
options(width=52)
@

\begin{objectifs}
\item Repérer et corriger des erreurs de programmation, syntaxiques et
  logiques.
\item Utiliser les outils de débogage de R.
\item Valider des résultats calculés avec ceux de l'expérimentation et
  analyser des résultats obtenus.
\end{objectifs}

Il est assez rare d'arriver à écrire un bout de code sans bogue du
premier coup. Par conséquent, qui dit programmation dit séances de
débogage. En fait, il n'est pas rare que le débogage et les tests de
validité accaparent la plus grande part du temps de développement d'un
projet.

Les techniques de débogages les plus simples et naïves sont parfois
les plus efficaces et certainement les plus faciles à apprendre.
Lorsqu'elles ne suffisent pas à la tâche, les outils de débogage de R
peuvent accélérer la résolution des problèmes. Je présente dans les
sections suivantes trois techniques de débogage que j'utilise
régulièrement, de la plus simple à la plus puissante.

Au cours du chapitre, nous allons tâcher de déboguer la fonction dont
le code se trouve à la \autoref{fig:debogage:rgamma_ar}. Il s'agit de
la fonction \code{rgamma\_ar} des exemples du
\autoref{chap:collaboration} (sans les commentaires) dans laquelle
j'ai inséré quelques petites anomalies. Voyons voir si nous pouvons
les trouver --- autrement que par comparaison avec une version
antérieure, bien sûr!

\begin{figure}
\begin{lstlisting}[frame=single,language=R]
rgamma_ar <- function(n, shape, rate = 1; scale = 1/rate)
{
    if (shape <= 0 | shape >= 1)
        stop("valeur de shape inadmissible")

    ratio <- function(x)
        if (x <= 1) exp(-x) else x^(shape - 1)

    Ginv <- function(x)
    {
        k <- 1 + shape * exp(-1)
        if (x <= 1/k)
            (k * x)^(1/shape)
        else
            -log(((1/shape) + exp(-1)) * (1 - x))
    }

    x <- numeric(n)
    i <- 1
    while (i < n)
    {
        y <- Ginv(runif(1)
        if (runif(1) <= ratio(y))
            x[i <- i + 1] <- y
    }
    x * scale
}
\end{lstlisting}
  \caption{Code d'une fonction à déboguer}
  \label{fig:debogage:rgamma_ar}
\end{figure}


\section{Erreurs simples et affichage de résultats intermédiaires}
\label{sec:debogage:simple}

Les simples erreurs de syntaxe sont de loin les plus fréquentes --- en
particulier l'oubli de parenthèses ou d'accolades. Ici, votre premier
outil de débogage demeure votre éditeur de texte pour programmeur ---
d'où l'importance d'en utiliser un bon. D'ailleurs, je vous recommande
de lire l'argumentaire bien plus développé sur le sujet de
\cite[chapitre~3]{Hunt:pragmatic:1999}.

Un bon éditeur de texte va, entre autres, indenter le code
automatiquement en fonction de ce que contient le code, plutôt qu'en
fonction de ce que vous \emph{pensez} qu'il contient. J'utilise
l'éditeur GNU~Emacs depuis de nombreuses années pour des tâches
d'édition de diverses natures et jamais je n'ai pris le moteur
d'indentation en défaut. En d'autres termes, quand Emacs ne dispose
pas le code comme je pense qu'il devrait l'être, c'est moi qui ai fait
une erreur quelque part. Pratique.

La simple édition du code de la \autoref{fig:debogage:rgamma_ar} avec
un bon outil fait immédiatement ressortir un premier problème dans la
boucle \code{while}, qui se retrouve indentée comme ceci:
\begin{Schunk}
\begin{Verbatim}
    while (i < n)
    {
        y <- Ginv(runif(1)
                  if (runif(1) <= ratio(y))
                      x[i <- i + 1] <- y
    }
\end{Verbatim}
\end{Schunk}

C'est ainsi que nous remarquons qu'il manque une parenthèse fermante
dans l'expression \code{y <- Ginv(runif(1)}. Voilà déjà une erreur
de corrigée.

Lors de la définition d'une fonction, l'interpréteur R effectue une
vérification de la syntaxe. Cela permet de détecter plusieurs types
d'erreurs relativement simples à corriger. Prenez simplement garde:
une erreur peut prendre sa source plusieurs lignes avant celle que
l'interpréteur identifie comme causant problème.

Dans notre exemple, l'interpréteur identifie correctement que nous
avons utilisé un point-virgule «\code{;}» en lieu et place d'une
virgule «\code{,}» pour séparer deux arguments dans la définition de
la fonction:
\begin{Schunk}
\begin{Verbatim}
Erreur : ';' inattendu(e) in
"rgamma_ar <- function(n, shape, rate = 1;"
\end{Verbatim}
\end{Schunk}

Avec ces deux erreurs maintenant corrigées, nous pouvons définir la
fonction dans l'espace de travail et l'utiliser sans erreur
d'exécution.
<<echo=FALSE>>=
rgamma_ar <- function(n, shape, rate = 1; scale = 1/rate)
{
    if (shape <= 0 | shape >= 1)
        stop("valeur de shape inadmissible")

    ratio <- function(x)
        if (x <= 1) exp(-x) else x^(shape - 1)

    Ginv <- function(x)
    {
        k <- 1 + shape * exp(-1)
        if (x <= 1/k)
            (k * x)^(1/shape)
        else
            -log(((1/shape) + exp(-1)) * (1 - x))
    }

    x <- numeric(n)
    i <- 1
    while (i < n)
    {
        y <- Ginv(runif(1))
        if (runif(1) <= ratio(y))
            x[i <- i + 1] <- y
    }
    x * scale
}
@
<<echo=TRUE>>=
rgamma_ar(5, 0.5, 1)
@



 Les messages d'erreur de l'interprète ne sont pas toujours d'un
  grand secours{\dots} tant que l'on n'a pas appris à les reconnaître.
  Un exemple de message d'erreur fréquemment rencontré:
  \begin{quote}
    \code{valeur manquante là où TRUE / FALSE est requis}
  \end{quote}
  Cette erreur provient généralement d'une commande \fonction{if} dont
  l'argument vaut \objet{NA} plutôt que \objet{TRUE} ou \objet{FALSE}.
  La raison: des valeurs manquantes se sont faufilées dans les
  calculs à notre insu jusqu'à l'instruction \fonction{if}, faisant en
  sorte que l'argument de \fonction{if} vaut \code{NA} alors qu'il ne
  peut être que booléen.

 Boucles: un calcul en trop ou un manquant.
 Fonction \code{apply}: application sur la mauvaise dimension.
 Attention au recyclage des vecteurs: ce n'est pas parce qu'un
  calcul s'effectue sans erreur apparente que c'est le bon calcul.





\begin{itemize}
\item Les erreurs de syntaxe sont les plus fréquentes (en particulier
  l'oubli de virgules). Lors de la définition d'une fonction, une
  vérification de la syntaxe est effectuée par l'interprète R.
  Attention, cependant: une erreur peut prendre sa source plusieurs
  lignes avant celle que l'interprète pointe comme causant problème.

  ici, indentation un bon indice; votre premier outil de débogage,
  c'est votre éditeur de texte --- d'où l'importance d'en utiliser un
  bon. Dans Emacs, lorsque l'indentation n'est pas celle attendue,
  c'est qu'il y a une erreur dans le code.

\item Les messages d'erreur de l'interprète ne sont pas toujours d'un
  grand secours{\dots} tant que l'on n'a pas appris à les reconnaître.
  Un exemple de message d'erreur fréquemment rencontré:
  \begin{quote}
    \code{valeur manquante là où TRUE / FALSE est requis}
  \end{quote}
  Cette erreur provient généralement d'une commande \fonction{if} dont
  l'argument vaut \objet{NA} plutôt que \objet{TRUE} ou \objet{FALSE}.
  La raison: des valeurs manquantes se sont faufilées dans les
  calculs à notre insu jusqu'à l'instruction \fonction{if}, faisant en
  sorte que l'argument de \fonction{if} vaut \code{NA} alors qu'il ne
  peut être que booléen.

\item Boucles: un calcul en trop ou un manquant.
\item Fonction \code{apply}: application sur la mauvaise dimension.
\item Attention au recyclage des vecteurs: ce n'est pas parce qu'un
  calcul s'effectue sans erreur apparente que c'est le bon calcul.

\item Lorsqu'une fonction ne retourne pas le résultat attendu, placer
  des commandes \fonction{print} à l'intérieur de la fonction, de
  façon à pouvoir suivre les valeurs prises par les différentes
  variables.

  Par exemple, la modification suivante à la boucle de la fonction
  \code{fp} permet d'afficher les valeurs successives de la variable
  \code{i} et de détecter, par exemple, une procédure itérative divergente:
  \begin{Schunk}
\begin{Verbatim}
repeat
{
    it <- i
    i <- (1 - (1 + it)^(-n))/k
    print(i)
    if (abs((i - it)/it < TOL))
        break
}
\end{Verbatim}
  \end{Schunk}
\item Quand ce qui précède ne fonctionne pas, ne reste souvent qu'à
  exécuter manuellement la fonction. Pour ce faire, définir dans
  l'espace de travail tous les arguments de la fonction, puis exécuter
  le corps de la fonction ligne par ligne. La vérification du résultat
  de chaque ligne permet généralement de retrouver la ou les
  expressions qui causent problème.
\end{itemize}


\section{Exécution pas-à-pas}
\label{sec:debogage:pas-a-pas}


\section{Arrêt du déroulement}
\label{sec:debogage:browser}




%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
