%%% Copyright (C) 2017 Vincent Goulet
%%%
%%% Ce fichier fait partie du projet «Programmer avec R»
%%% http://github.com/vigou3/programmer-avec-r
%%%
%%% Cette création est mise à disposition selon le contrat
%%% Attribution-Partage dans les mêmes conditions 4.0
%%% International de Creative Commons.
%%% http://creativecommons.org/licenses/by-sa/4.0/

\chapter{Débogage}
\label{chap:debogage}

<<echo=FALSE>>=
options(width=52)
@

\begin{objectifs}
\item Repérer et corriger des erreurs de programmation, syntaxiques et
  logiques.
\item Utiliser les outils de débogage de R.
\item Valider des résultats calculés avec ceux de l'expérimentation et
  analyser des résultats obtenus.
\end{objectifs}

Il est assez rare d'arriver à écrire un bout de code sans bogue du
premier coup. Par conséquent, qui dit programmation dit séances de
débogage. En fait, il n'est pas rare que le débogage et les tests de
validité accaparent la plus grande part du temps de développement d'un
projet.

Les techniques de débogages les plus simples et naïves sont parfois
les plus efficaces et certainement les plus faciles à apprendre.
Lorsqu'elles ne suffisent pas à la tâche, les outils de débogage de R
peuvent accélérer la résolution des problèmes. Je présente dans les
sections suivantes trois techniques de débogage que j'utilise
régulièrement, de la plus simple à la plus puissante.

Au cours du chapitre, nous allons tâcher de déboguer la fonction dont
le code se trouve à la \autoref{fig:debogage:rgamma_ar}. Il s'agit de
la fonction \code{rgamma\_ar} des exemples du
\autoref{chap:collaboration} (sans les commentaires) dans laquelle
j'ai inséré quelques petites anomalies. Voyons voir si nous pouvons
les trouver --- autrement que par comparaison avec une version
antérieure, bien sûr!

\begin{figure}
\begin{lstlisting}[frame=single, numbers=left, language=R]
rgamma_ar <- function(n, shape, rate = 1; scale = 1/rate)
{
    if (shape <= 0 | shape >= 1)
        stop("valeur de shape inadmissible")

    ratio <- function(x)
        if (x <= 1) exp(-x) else x^(shape - 1)

    Ginv <- function(x)
    {
        k <- 1 + shape * exp(-1)
        if (x <= 1/k)
            (k * x)^(1/shape)
        else
            -log(((1/shape) + exp(-1)) * (1 - x))
    }

    x <- numeric(n)
    i <- 1
    while (i < n)
    {
        y <- Ginv(runif(1)
        if (runif(1) <= ratio(y))
            x[i <- i + 1] <- y
    }
    x * scale
}
\end{lstlisting}
  \caption{Code d'une fonction à déboguer}
  \label{fig:debogage:rgamma_ar}
\end{figure}


\section{Erreurs simples et affichage de résultats intermédiaires}
\label{sec:debogage:simple}

Les simples erreurs de syntaxe sont de loin les plus fréquentes --- en
particulier l'oubli de parenthèses ou d'accolades. Ici, votre premier
outil de débogage demeure votre éditeur de texte pour programmeur ---
d'où l'importance d'en utiliser un bon. D'ailleurs, je vous recommande
de lire l'argumentaire bien plus développé sur le sujet de
\citet[chapitre~3]{Hunt:pragmatic:1999}.

Un bon éditeur de texte va, entre autres choses, indenter le code
automatiquement en fonction de ce qu'il contient, et non en fonction
de ce que vous \emph{pensez} qu'il contient. J'utilise pour ma part
l'éditeur GNU~Emacs depuis de nombreuses années pour des tâches
d'édition de diverses natures et jamais je n'ai pris le moteur
d'indentation en défaut. En d'autres termes, quand Emacs ne dispose
pas le code comme je pense qu'il devrait l'être, c'est moi qui ai fait
une erreur quelque part. Pratique.

La simple édition du code de la \autoref{fig:debogage:rgamma_ar} avec
un bon outil fait immédiatement ressortir un premier problème dans la
boucle \code{while} (lignes 20--25), qui se retrouve indentée comme
ci-dessous.
\begin{Schunk}
\begin{Verbatim}
while (i < n)
{
    y <- Ginv(runif(1)
              if (runif(1) <= ratio(y))
                  x[i <- i + 1] <- y
}
\end{Verbatim}
\end{Schunk}

C'est ainsi que nous remarquons qu'il manque une parenthèse fermante
dans l'expression \code{y <- Ginv(runif(1)}. Voilà déjà une erreur
de corrigée.

Lors de la définition d'une fonction, l'interpréteur R effectue une
vérification de la syntaxe. Cela permet de détecter plusieurs types
d'erreurs relativement simples à corriger. Prenez simplement garde:
une erreur peut prendre sa source plusieurs lignes avant celle que
l'interpréteur identifie comme causant problème.

Dans notre exemple, l'interpréteur identifie correctement que nous
avons utilisé un point-virgule «\code{;}» en lieu et place d'une
virgule «\code{,}» pour séparer deux arguments dans la définition de
la fonction.
\begin{Schunk}
\begin{Verbatim}
Erreur : ';' inattendu(e) in
"rgamma_ar <- function(n, shape, rate = 1;"
\end{Verbatim}
\end{Schunk}

Avec ces deux erreurs maintenant corrigées, nous pouvons définir la
fonction dans l'espace de travail et l'utiliser sans erreur
d'exécution.
<<echo=FALSE>>=
rgamma_ar <- function(n, shape, rate = 1, scale = 1/rate)
{
    if (shape <= 0 | shape >= 1)
        stop("valeur de shape inadmissible")

    ratio <- function(x)
        if (x <= 1) exp(-x) else x^(shape - 1)

    Ginv <- function(x)
    {
        k <- 1 + shape * exp(-1)
        if (x <= 1/k)
            (k * x)^(1/shape)
        else
            -log(((1/shape) + exp(-1)) * (1 - x))
    }

    x <- numeric(n)
    i <- 1
    while (i < n)
    {
        y <- Ginv(runif(1))
        if (runif(1) <= ratio(y))
            x[i <- i + 1] <- y
    }
    x * scale
}
@
<<echo=TRUE>>=
rgamma_ar(5, 0.5, 1)
@

Les personnes un tant soit peu familières avec la distribution gamma
auront tôt fait de remarquer une anomalie dans les résultats
ci-dessus: la distribution étant strictement positive, elle ne peut
générer la valeur $0$ que l'on retrouve en première position du
vecteur.

Une des premières choses à investiguer lorsqu'un bogue survient, c'est
s'il est \emph{reproductible}, tant avec les mêmes conditions d'entrée
(les valeurs des arguments) que sous d'autres conditions. Voyons voir.
<<echo=TRUE>>=
rgamma_ar(5, 0.5, 1)
rgamma_ar(5, 0.8, 1)
rgamma_ar(5, 0.5, 2)
rgamma_ar(10, 0.5, 1)
rgamma_ar(1, 0.5, 1)
@

Il semble y avoir une constante, ici: c'est toujours la première
valeur du vecteur de résultats qui est nulle, quelque soit le nombre de
valeurs aléatoires demandé ou la paramétrisation de la loi gamma. Cela
disculpe fort probablement les fonctions internes \code{ratio} et
\code{Ginv} puisqu'elles semblent faire leur travail correctement pour
les cas autres que le tout premier.

Dès qu'une fonction comporte une boucle, vos efforts de débogage
devraient se tourner de ce côté. En effet, il est très facile de se
tromper dans le critère d'arrêt d'une boucle, de telle sorte qu'il
manque une itération ou, à l'inverse, qu'il y en a une de trop. Il
faut également examiner l'effet des compteurs de près: seraient-ils
incrémentés trop tôt ou trop tard dans la boucle?

Il est temps de regarder une première technique de débogage, de loin
la plus simple. Lorsqu'une fonction ne retourne pas le résultat
attendu, placez des commandes \icode{print} à des endroits
stratégiques dans la fonction de façon à pouvoir suivre les valeurs
prises par les différents objets. Dans notre exemple, nous aimerions
suivre les valeurs du vecteur \code{x}, du compteur \code{i} et de
l'objet \code{y}. Pour ce faire, nous remplaçons les lignes 20 à 25 de
la \autoref{fig:debogage:rgamma_ar} par l'extrait de code
ci-dessous\footnote{%
  Le code modifié est fourni en exemple dans la
  \autoref{sec:debogage:exemples}.}, %
puis nous exécutons de nouveau la fonction.
\begin{Schunk}
\begin{Verbatim}
while (i < n)
{
    y <- Ginv(runif(1))
    if (runif(1) <= ratio(y))
    {
        print(paste("valeur de y acceptée:", y))
        x[i <- i + 1] <- y
        print(c(i, x))
    }
}
\end{Verbatim}
\end{Schunk}
<<echo=FALSE>>=
rgamma_ar <- function(n, shape, rate = 1, scale = 1/rate)
{
    if (shape <= 0 | shape >= 1)
        stop("valeur de shape inadmissible")
    ratio <- function(x)
        if (x <= 1) exp(-x) else x^(shape - 1)
    Ginv <- function(x)
    {
        k <- 1 + shape * exp(-1)
        if (x <= 1/k)
            (k * x)^(1/shape)
        else
            -log(((1/shape) + exp(-1)) * (1 - x))
    }
    x <- numeric(n)
    i <- 1
    while (i < n)
    {
        y <- Ginv(runif(1))
        if (runif(1) <= ratio(y))
        {
            print(paste("valeur de y acceptée:", y))
            x[i <- i + 1] <- y
            print(c(i, x))
        }
    }
    x * scale
}
@
<<echo=TRUE>>=
rgamma_ar(5, 0.5, 1)
@

Les résultats précédents nous apprennent que lorsque la première
valeur \code{y} est acceptée, elle est placée en seconde position dans
le vecteur \code{x}. Le coupable est donc notre compteur \code{i}! En
y regardant de plus près, nous réalisons, en effet, qu'il est
initialisé à la valeur $1$ à l'extérieur de la boucle \code{while}
(ligne 19 de la \autoref{fig:debogage:rgamma_ar}) et qu'il est ensuite
incrémenté \emph{avant} que l'affectation dans \code{x} ne soit
effectuée dans la clause \code{if} (ligne 24). Le correctif est donc
facile à appliquer: initialiser \code{i} avec la valeur $0$. Ceci
fait, la fonction retourne maintenant des valeurs plausibles.
<<echo=FALSE>>=
rgamma_ar <- function(n, shape, rate = 1, scale = 1/rate)
{
    if (shape <= 0 | shape >= 1)
        stop("valeur de shape inadmissible")
    ratio <- function(x)
        if (x <= 1) exp(-x) else x^(shape - 1)
    Ginv <- function(x)
    {
        k <- 1 + shape * exp(-1)
        if (x <= 1/k)
            (k * x)^(1/shape)
        else
            -log(((1/shape) + exp(-1)) * (1 - x))
    }
    x <- numeric(n)
    i <- 0
    while (i < n)
    {
        y <- Ginv(runif(1))
        if (runif(1) <= ratio(y))
        {
            print(paste("valeur de y acceptée:", y))
            x[i <- i + 1] <- y
            print(c(i, x))
        }
    }
    x * scale
}
@
<<echo=TRUE>>=
rgamma_ar(5, 0.5, 1)
@

En l'état, la fonction \code{rgamma\_ar} semble valide. Je vous
rappelle la mise en garde de la
\autoref{sec:bases:vecteurs:arithmetique}: avec le recyclage des
vecteurs dans R, ce n'est pas parce qu'une expression --- ou une
fonction --- s'exécute sans erreur apparente que le calcul effectué
est bon pour autant. Il faut vérifier l'exactitude des calculs à
l'aide de tests de contrôle. Le sujet ne sera pas étudié plus avant
ici.



\begin{itemize}
\item Quand ce qui précède ne fonctionne pas, ne reste souvent qu'à
  exécuter manuellement la fonction. Pour ce faire, définir dans
  l'espace de travail tous les arguments de la fonction, puis exécuter
  le corps de la fonction ligne par ligne. La vérification du résultat
  de chaque ligne permet généralement de retrouver la ou les
  expressions qui causent problème.
\item  Les messages d'erreur de l'interprète ne sont pas toujours d'un
  grand secours{\dots} tant que l'on n'a pas appris à les reconnaître.
  Un exemple de message d'erreur fréquemment rencontré:
  \begin{quote}
    \code{valeur manquante là où TRUE / FALSE est requis}
  \end{quote}
  Cette erreur provient généralement d'une commande \code{if} dont
  l'argument vaut \code{NA} plutôt que \code{TRUE} ou \code{FALSE}.
  La raison: des valeurs manquantes se sont faufilées dans les
  calculs à notre insu jusqu'à l'instruction \code{if}, faisant en
  sorte que l'argument de \code{if} vaut \code{NA} alors qu'il ne
  peut être que booléen.
\item
 Boucles: un calcul en trop ou un manquant.
 Fonction \code{apply}: application sur la mauvaise dimension.
 Attention au recyclage des vecteurs: ce n'est pas parce qu'un
  calcul s'effectue sans erreur apparente que c'est le bon calcul.


\end{itemize}


\section{Exécution pas-à-pas}
\label{sec:debogage:pas-a-pas}


\section{Arrêt du déroulement}
\label{sec:debogage:browser}


\section{Exemples}
\label{sec:debogage:exemples}

\def\scriptfilename{debogage.R}

\scriptfile{\scriptfilename}
\lstinputlisting[firstline=13]{\scriptfilename}





%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: "programmer-avec-r"
%%% coding: utf-8
%%% End:
