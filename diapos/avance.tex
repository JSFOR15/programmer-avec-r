\section{Concepts avancés}

\subsection{L'argument `\code{...}'}

\begin{frame}
  \frametitle{Pas un signe de paresse des rédacteurs}

  \begin{itemize}
  \item `\code{...}' est un argument formel dont `\code{...}' est le
    nom
  \item Fonction accepte un ou plusieurs arguments autres que ceux
    faisant partie de sa définition
  \item Contenu de `\code{...}'  ni pris en compte, ni modifié par la
    fonction
  \item Passé tel quel à une autre fonction
  \item Exemples: \fonction{apply}, \fonction{lapply},
    \fonction{sapply}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exemple}
\begin{Sinput}
> f <- function(x, y) x + y
> g <- function(z, ...) z * f(...)
\end{Sinput}
  \pause
\begin{Sinput}
> g(2, 3, 4)
\end{Sinput}
\begin{Soutput}
[1] 14
\end{Soutput}
\end{frame}

\subsection{Fonction \code{apply}}

\begin{frame}
  \frametitle{Sommaires généraux pour matrices et tableaux}

  \Fonction{apply} applique une fonction quelconque sur une partie
  d'une matrice ou d'un tableau
  \pause
  \begin{center}
    \code{apply(X, MARGIN, FUN, ...)}
  \end{center}
  où
  \begin{itemize}
  \item \code{X}:  matrice ou tableau
  \item \code{MARGIN}: vecteur de la ou des dimensions sur lesquelles
    la fonction doit s'appliquer
  \item \code{FUN}: fonction à appliquer
  \item `\code{...}': arguments supplémentaires à passer à \code{FUN}
  \end{itemize}
\end{frame}

% \begin{frame}
%   \frametitle{Utilisation}

%   \begin{itemize}
%   \item Principalement pour calculer des sommaires par ligne
%     (dimension 1) ou par colonne (dimension 2) autres que la somme et
%     la moyenne
%   \item Utiliser la fonction \fonction{apply} plutôt que des boucles
%   \end{itemize}
% \end{frame}

\begin{frame}[fragile]
  \frametitle{Exemples avec une matrice}
\begin{Schunk}
\begin{Sinput}
> m
\end{Sinput}
\begin{Soutput}
     [,1] [,2] [,3] [,4]
[1,]   54   33   30   17
[2,]    3   46   95   83
[3,]   47    6   56   58
[4,]   18   22   50   36
[5,]   41   41   77   31
\end{Soutput}
  \pause
\begin{Sinput}
> apply(m, 1, var)
\end{Sinput}
\begin{Soutput}
[1]  235.0000 1718.9167  590.9167  211.6667
[5]  409.0000
\end{Soutput}
  \pause
\begin{Sinput}
> apply(m, 2, min)
\end{Sinput}
\begin{Soutput}
[1]  3  6 30 17
\end{Soutput}
  \pause
\begin{Sinput}
> apply(m, 1, mean, trim = 0.2)
\end{Sinput}
\begin{Soutput}
[1] 33.50 56.75 41.75 31.50 47.50
\end{Soutput}
\end{Schunk}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exemple avec un tableau}

\begin{Schunk}
\begin{Sinput}
> dim(arr)
\end{Sinput}
\begin{Soutput}
[1] 4 4 5
\end{Soutput}
\begin{Sinput}
> apply(arr, 3, det)
\end{Sinput}
\begin{Soutput}
[1]  1178800 16153716 14298240 20093933
[5]  6934743
\end{Soutput}
\end{Schunk}
\end{frame}


\subsection{Fonctions \code{lapply} et \code{sapply}}

\begin{frame}
  \frametitle{Les \code{apply} des vecteurs et des listes}

  \begin{itemize}
  \item \Fonction{lapply} et \Fonction{sapply} appliquent une fonction
    aux éléments d'un \alert{vecteur} ou d'une \alert{liste}
  \item  Syntaxe similaire à \fonction{apply}:
    \begin{center}
      \code{lapply(X, FUN, ...)} \\
      \code{sapply(X, FUN, ...)}
    \end{center}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Des fonctions très utiles}

  \begin{itemize}
  \item \fonction{\textbf{l}apply} retourne le résultat sous forme de liste
  \item \fonction{\textbf{s}apply} similaire, sauf que:
    \begin{itemize}
    \item résultat sous forme de vecteur, si possible
    \item si chaque résultat de \code{FUN} est un vecteur,
      \fonction{sapply} retourne une matrice
    \end{itemize}
  \item Souvent possible de remplacer les boucles \fonction{for} par
    l'utilisation de \fonction{lapply} ou \fonction{sapply}
  \end{itemize}
\end{frame}


\subsection{Fonction \code{mapply}}

\begin{frame}
  \frametitle{Version multidimensionnelle de \code{sapply}}

  \begin{itemize}[<+->]
  \item Syntaxe:
    \begin{center}
      \code{mapply(FUN, ...)}
    \end{center}
  \item Le résultat est l'application de \code{FUN} aux premiers
    éléments de tous les arguments contenus dans `\code{...}', puis à
    tous les seconds éléments, et ainsi de suite
  \item Ainsi, si \code{v} et \code{w} sont des vecteurs,
    \begin{center}
      \code{mapply(FUN, v, w)}
    \end{center}
    retourne \code{FUN(v[1], w[1])}, \code{FUN(v[2], w[2])}, etc.
  \end{itemize}
\end{frame}

% \begin{frame}[fragile]
%   \frametitle{Exemple}

% \begin{Schunk}
% \begin{Sinput}
% > mapply(rep, 1:4, 4:1)
% \end{Sinput}
%   \pause
% \begin{Soutput}
% [[1]]
% [1] 1 1 1 1

% [[2]]
% [1] 2 2 2

% [[3]]
% [1] 3 3

% [[4]]
% [1] 4
% \end{Soutput}
% \end{Schunk}
% \end{frame}

\begin{frame}[fragile=singleslide]
  \frametitle{Exemple}
\begin{Schunk}
\begin{Sinput}
> mapply(seq, 1:6, 6:8)
\end{Sinput}
\begin{Soutput}
[[1]]
[1] 1 2 3 4 5 6

[[2]]
[1] 2 3 4 5 6 7

[[3]]
[1] 3 4 5 6 7 8

[[4]]
[1] 4 5 6

[[5]]
[1] 5 6 7

[[6]]
[1] 6 7 8
\end{Soutput}
\end{Schunk}
\end{frame}


\subsection{Fonction \code{replicate}}

\begin{frame}[fragile]
  \frametitle{Une fonction pour la simulation}

  \begin{itemize}
  \item Simplifie la syntaxe pour l'exécution répétée d'une
    expression
  \item Particulièrement indiqué pour les simulations
  \item Si la fonction \code{fun} fait tous les calculs d'une
    simulation, on obtient les résultats pour \nombre{10000}
    simulations avec
\begin{Schunk}
\begin{Sinput}
> replicate(10000, fun(...))
\end{Sinput}
\end{Schunk}
  \item Voir l'annexe D du document d'accompagnement
  \end{itemize}
\end{frame}


\subsection{Classes et fonctions génériques}

\begin{frame}
  \frametitle{Quelques notions de programmation OO}

  \begin{itemize}
  \item Tous les objets dans le langage S ont une classe
  \item Classe parfois implicite ou dérivée du mode de l'objet
  \item Fonctions \alert{génériques} se comportent différemment selon
    la classe de l'objet donné en argument
  \item Fonctions génériques les plus fréquemment employées:
    \fonction{print}, \fonction{plot}, \fonction{summary}
  \item Une fonction générique possède une \alert{méthode}
    correspondant à chaque classe qu'elle reconnaît
  \item Sinon, une méthode \code{default} pour les autres objets
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]
  \begin{itemize}
  \item La liste des méthodes existant pour une fonction générique
    s'obtient avec \Fonction{methods}:
\begin{Schunk}
\begin{Sinput}
> methods(plot)
\end{Sinput}
\begin{Soutput}
 [1] plot.acf*       plot.data.frame*
 [3] plot.Date*      plot.decomposed.ts*
 [5] plot.default    plot.dendrogram*
 [7] plot.density    plot.ecdf
 [9] plot.factor*    plot.formula*
[11] plot.hclust*    plot.histogram*

[...]

   Non-visible functions are asterisked
\end{Soutput}
\end{Schunk}
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{itemize}
  \item À chaque méthode \code{methode} d'une fonction générique
    \code{fun} correspond une fonction \code{fun.methode}
  \item Consulter cette rubrique d'aide et non celle de la fonction
    générique, qui contient en général peu d'informations
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{alertblock}{Astuce}
    Lorsque l'on tape le nom d'un objet à la ligne de commande
    pour voir son contenu, c'est la fonction générique
    \fonction{print} qui est appelée.

    On peut donc complètement modifier la représentation à l'écran du
    contenu d'un objet est créant une nouvelle classe et une nouvelle
    méthode pour la fonction \code{print}.
  \end{alertblock}
\end{frame}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "introduction_programmation_S_diapos"
%%% End:
