\section{Opérateurs et fonctions}

\begin{frame}
  \frametitle{Une liste non exhaustive}

  \begin{itemize}
  \item Principaux opérateurs arithmétiques, fonctions mathématiques
    et structures de contrôles
  \item Consulter aussi la section \texttt{See Also} des rubriques
    d'aide
  \end{itemize}
\end{frame}


\subsection{Opérations arithmétiques}

\begin{frame}[fragile=singleslide]
  \frametitle{L'unité de base est le vecteur}

  \begin{itemize}
  \item Les opérations sur les vecteurs sont effectuées \alert{élément
      par élément}:
\begin{Schunk}
\begin{Sinput}
> c(1, 2, 3) + c(4, 5, 6)
\end{Sinput}
\begin{Soutput}
[1] 5 7 9
\end{Soutput}
\begin{Sinput}
> 1:3 * 4:6
\end{Sinput}
\begin{Soutput}
[1]  4 10 18
\end{Soutput}
\end{Schunk}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]
  \frametitle{Recyclage des vecteurs}

  \begin{itemize}
  \item Si les vecteurs impliqués dans une expression arithmétique ne
    sont pas de la même longueur, les plus courts sont
    \alert{recyclés}
  \item Particulièrement apparent avec les vecteurs de longueur 1:
\begin{Schunk}
\begin{Sinput}
> 1:10 + 2
\end{Sinput}
\begin{Soutput}
 [1]  3  4  5  6  7  8  9 10 11 12
\end{Soutput}
\begin{Sinput}
> 1:10 + rep(2, 10)
\end{Sinput}
\begin{Soutput}
 [1]  3  4  5  6  7  8  9 10 11 12
\end{Soutput}
\end{Schunk}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]
  \frametitle{Longueur du plus long vecteur multiple de celle des
    autres vecteurs}

  \begin{itemize}
  \item Les vecteurs les plus courts sont recyclés un nombre entier de
    fois:
\begin{Schunk}
\begin{Sinput}
> 1:10 + 1:5 + c(2, 4)
\end{Sinput}
\begin{Soutput}
[1]  4  8  8 12 12 11 11 15 15 19
\end{Soutput}
\begin{Sinput}
> 1:10 + rep(1:5, 2) + rep(c(2, 4), 5)
\end{Sinput}
\begin{Soutput}
[1]  4  8  8 12 12 11 11 15 15 19
\end{Soutput}
\end{Schunk}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]
  \frametitle{Sinon...}

  \begin{itemize}
  \item Recyclage un nombre fractionnaire de fois et un avertissement
    est affiché:
\begin{Schunk}
\begin{Sinput}
> 1:10 + c(2, 4, 6)
\end{Sinput}
\begin{Soutput}
[1]  3  6  9  6  9 12  9 12 15 12
Message d'avis :
la longueur de l'objet le plus long n'est
pas un multiple de la longueur de l'objet
le plus court in: 1:10 + c(2, 4, 6)
\end{Soutput}
\end{Schunk}
  \end{itemize}
\end{frame}


\subsection{Opérateurs}

\begin{frame}[fragile=singleslide]
  \frametitle{Opérateurs mathématiques et logiques}

  Ordre décroissant de priorité des opérations.

  \begin{center}
    \renewcommand{\arraystretch}{1.2}
    \begin{tabular}{lp{30ex}}
      \Fonction{\^} ou \Fonction{**} & puissance \\
      \Fonction{-} & changement de signe \\
      \Fonction{*} \Fonction{/} & multiplication, division \\
      \Fonction{+} \Fonction{-} & addition, soustraction \\
      \Fonction{\%*\%} \Fonction{\%\%} \Fonction{\%/\%} & produit
      matriciel, modulo, division entière \\
      \Fonction{<} \Fonction{<=} \Fonction{==} \Fonction{>=}
      \Fonction{>} \verb|!=| & plus petit, plus petit ou égal, égal,
      plus grand ou égal, plus grand, différent de \\
      \verb|!| & négation logique \\
      \Fonction{\&} \Fonction{|} & «et» logique, «ou» logique \\
    \end{tabular}
  \end{center}
\end{frame}

\subsection{Appels de fonctions}

\begin{frame}
  \frametitle{Spécification des arguments d'une fonction}

  \begin{itemize}[<+->]
  \item Pas de limite pratique au nombre d'arguments
  \item Dans l'ordre établi dans la définition de la fonction
  \item Plus prudent et \alert{fortement recommandé} de spécifier par
    le nom des arguments, surtout après les deux ou trois premiers
  \item Nécessaire de nommer les arguments s'ils ne sont pas appelés
    dans l'ordre
  \item Certains arguments ont une valeur par défaut qui sera utilisée
    si l'argument n'est pas spécifié
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exemple}

  Définition de la fonction \texttt{matrix}:

\begin{semiverbatim}
    matrix({\color{red}data = NA}, {\color{blue}nrow = 1}, {\color{magenta}ncol = 1},
           {\color{orange}byrow = FALSE}, {\color{brown}dimnames = NULL})
\end{semiverbatim}
  \pause
  \begin{itemize}
  \item Chaque argument a une valeur par défaut (ce n'est pas toujours
    le cas)
  \item Un appel à \code{matrix} sans argument résulte en
\begin{Schunk}
\begin{Sinput}
> matrix()
\end{Sinput}
\begin{Soutput}
     [,1]
[1,]   NA
\end{Soutput}
\end{Schunk}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]

  \begin{itemize}
  \item Appel plus élaboré utilisant tous les arguments (le premier
    est rarement nommé):
\begin{semiverbatim}
\itshape
> matrix({\color{red}1\!\!\!:6}, {\color{blue}nrow = 2}, {\color{magenta}ncol = 3},
+  {\color{orange}byrow = TRUE},
+  {\color{brown}dimnames = list(c("Gauche", "Droit"),
+    c("Rouge", "Vert", "Bleu")))})
\end{semiverbatim}
\begin{Soutput}
       Rouge Vert Bleu
Gauche     1    2    3
Droit      4    5    6
\end{Soutput}
  \end{itemize}
\end{frame}


\subsection{Quelques fonctions utiles}

\begin{frame}
  \frametitle{Système de classement des fonctions}

  \begin{itemize}
  \item Dans \textsf{R}, un ensemble de fonctions est appelé un
    \alert{package}
  \item Par défaut, \textsf{R} charge en mémoire quelques packages de
    la bibliothèque (\emph{library}) seulement
  \item Cela économise l'espace mémoire et accélère le démarrage
  \item On charge de nouveaux packages en mémoire avec la fonction
    \fonction{library}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Manipulation de vecteurs}

  \begin{ttscript}{unique}
  \item[\Fonction{seq}] suites de nombres
  \item[\Fonction{rep}] répétition de valeurs ou de vecteurs
  \item[\Fonction{sort}] tri en ordre croissant ou décroissant
  \item[\Fonction{order}] positions des valeurs en ordre croissant ou
    décroissant
  \item[\Fonction{rank}] rang des éléments en ordre croissant ou
    décroissant
  \item[\Fonction{rev}] renverser un vecteur
  \item[\Fonction{head}] extraction des $n$ premières valeurs ou
    suppression des $n$ dernières
  \item[\Fonction{tail}] extraction des $n$ dernières valeurs ou
    suppression des $n$ premières
  \item[\Fonction{unique}] éléments différents
  \end{ttscript}
\end{frame}

\begin{frame}
  \frametitle{Recherche d'éléments dans un vecteur}
  \begin{ttscript}{which.max}
  \item[\Fonction{which}] positions des valeurs \texttt{TRUE} dans un
    vecteur booléen
  \item[\Fonction{which.min}] position du minimum
  \item[\Fonction{which.max}] position du maximum
  \item[\Fonction{match}] position de la première occurrence d'un
    élément
  \item[\Fonction{\%in\%}] appartenance d'une ou plusieurs valeurs à
    un vecteur
  \end{ttscript}
\end{frame}

\begin{frame}
  \frametitle{Arrondi}
  \begin{ttscript}{ceiling}
  \item[\Fonction{round}] arrondi un nombre défini de décimales
  \item[\Fonction{floor}] plus grand entier inférieur ou égal
  \item[\Fonction{ceiling}] plus petit entier supérieur ou égal
  \item[\Fonction{trunc}] troncature vers zéro; différent de
    \texttt{floor} pour les nombres négatifs
  \end{ttscript}
\end{frame}

\begin{frame}
  \frametitle{Sommaires et statistiques descriptives}
  \begin{ttscript}{sum, prod}
  \item[\Fonction{sum}, \Fonction{prod}] somme, produit
  \item[\Fonction{diff}] différences
  \item[\Fonction{mean}] moyennes arithmétique et tronquée
  \item[\Fonction{var}, \Fonction{sd}] variance, écart type
  \item[\Fonction{min}, \Fonction{max}] minimum, maximum
  \item[\Fonction{range}] minimum \alert{et} maximum
  \item[\Fonction{median}] médiane empirique
  \item[\Fonction{quantile}] quantiles empiriques
  \item[\Fonction{summary}] statistiques descriptives usuelles
  \end{ttscript}
\end{frame}

\begin{frame}
  \frametitle{Sommaires cumulatifs et comparaisons élément par
    élément}
  \begin{ttscript}{cumsum, cumprod}
  \item[\Fonction{cumsum}, \Fonction{cumprod}] somme cumulative,
    produit cumulatif
  \item[\Fonction{cummin}, \Fonction{cummax}] minimum et maximum
    cumulatif
  \item[\Fonction{pmin}, \Fonction{pmax}] minimum et maximum élément
    par élément (parallèle)
  \end{ttscript}
\end{frame}

\begin{frame}
  \frametitle{Opérations sur les matrices}
  \begin{ttscript}{nrow, ncol}
  \item[\Fonction{t}] transposée
  \item[\Fonction{solve}] inverse et résolution de systèmes
    d'équations linéaires
  \item[\Fonction{diag}] extraction de la diagonale d'une matrice;
    création d'une matrice diagonale; création d'une matrice identité
  \item[\Fonction{nrow}, \Fonction{ncol}] nombre de lignes, de
    colonnes d'une matrice
  \end{ttscript}
\end{frame}

\begin{frame}
  \frametitle{Opérations sur les matrices (suite)}
  \begin{ttscript}{rowMeans, colMeans}
  \item[\Fonction{rowSums}, \Fonction{colSums}] sommes par ligne, sommes
    par colonne
  \item[\Fonction{rowMeans}, \Fonction{colMeans}] moyennes par ligne,
    moyennes par colonne
  \end{ttscript}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Produit extérieur}
  \begin{itemize}
  \item<1-> Syntaxe: \code{outer(X, Y, FUN)}
  \item<1-> Applique la fonction \code{FUN} (\fonction{prod} par défaut)
    entre chacun des éléments de \code{X} et chacun des éléments de
    \code{Y}
  \item<1-> Dimension du résultat est \code{c(dim(X), dim(Y))}
  \item<2-> Exemple:
\begin{Schunk}
\begin{Sinput}
> outer(c(1, 2, 5), c(2, 3, 6))
\end{Sinput}
\begin{Soutput}
     [,1] [,2] [,3]
[1,]    2    3    6
[2,]    4    6   12
[3,]   10   15   30
\end{Soutput}
\end{Schunk}
  \item<3-> Raccourci: \code{X \%o\% Y}
  \end{itemize}
\end{frame}


\subsection{Structures de contrôle}

\begin{frame}
  \frametitle{Exécution conditionnelle}

  \begin{block}{\code{if (\emph{condition}) \emph{branche.vrai} else
      \emph{branche.faux}}}
  \begin{itemize}
  \item Exécuter \code{\emph{branche.vrai}} si \code{\emph{condition}}
    est vraie et \code{\emph{branche.faux}} sinon
  \item Lorsqu'une branche comporte plus d'une expression, les grouper
    dans des accolades $\{~\}$
  \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{\code{ifelse(\emph{vecteur.condition},
        \emph{vecteur.vrai}, \emph{vecteur.faux})}}
  \begin{itemize}
  \item Fonction vectorisée
  \item Pour chaque \code{TRUE} de \code{\emph{vecteur.condition}},
    retourne l'élément correspondant de \code{\emph{vecteur.vrai}} et
    pour chaque \code{FALSE} l'élément correspondant de
    \code{\emph{vecteur.faux}}
  \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Boucles}

  \begin{itemize}
  \item Les boucles sont et \alert{doivent} être utilisées avec
    parcimonie en S car elles sont généralement inefficaces
  \item En général possible de vectoriser les calcul pour éviter les
    boucles explicites
  \item Utiliser aussi les fonctions \fonction{apply},
    \fonction{lapply}, \fonction{sapply} et \code{mapply}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Boucles de longueur déterminée}

  \begin{block}{\code{for (\emph{variable} in \emph{suite}) \emph{expression}}}
    \begin{itemize}
    \item Exécuter \code{\emph{expression}} pour chaque valeur de
      \code{\emph{variable}} contenue dans \code{\emph{suite}}
    \item Grouper les expressions dans des accolades $\{~\}$
    \item \code{\emph{suite}} n'a pas à être composée de nombres
      consécutifs, ni même de nombres
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Boucles de longueur indéterminée}

  \begin{block}{\code{while (\emph{condition}) \emph{expression}}}
    \begin{itemize}
    \item Exécuter \code{\emph{expression}} tant que
      \code{\emph{condition}} est vraie
    \item Si \code{\emph{condition}} est fausse lors de l'entrée dans
      la boucle, celle-ci n'est pas exécutée
    \item \code{while} pas toujours exécutée
    \end{itemize}
  \end{block}

  \begin{block}{\code{repeat \emph{expression}}}
    \begin{itemize}
    \item Répéter \code{\emph{expression}}
    \item Nécessite un test d'arrêt avec un \code{break}
    \item \code{repeat} toujours exécutée au moins une fois
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Modification du déroulement d'une boucle}

  \begin{block}{\code{break}}
    Sortie immédiate d'une boucle \code{for}, \code{while} ou
    \code{repeat}
  \end{block}

  \begin{block}{\code{next}}
    Passage immédiat à la prochaine itération d'une boucle \code{for},
    \code{while} ou \code{repeat}
  \end{block}
\end{frame}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "introduction_programmation_S_diapos"
%%% End:
